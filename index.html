<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black-Scholes Greeks 3D Visualization</title>
    
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <!-- OrbitControls for camera manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        /* Overall layout */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: #111624;
            color: #ffffff;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Controls panel */
        .controls-panel {
            width: 300px;
            background-color: #1a2235;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #ffffff;
        }

        .control-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #2a3c54;
            border-radius: 4px;
            font-size: 14px;
            background-color: #1e293e;
            color: #ffffff;
        }

        .info-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2a3c54;
        }

        .info-panel h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .info-panel ul {
            padding-left: 20px;
            font-size: 13px;
            color: #aabbcc;
        }

        /* 3D visualization container */
        .visualization-container {
            flex: 1;
            position: relative;
            height: 600px;
            background-color: #111624;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        #plotContainer {
            width: 100%;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(17, 22, 36, 0.9);
            z-index: 10;
            font-weight: 600;
            gap: 15px;
            color: #ffffff;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 5px solid #1e293e;
            border-top: 5px solid #4f8fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-tips {
            font-size: 14px;
            color: #aabbcc;
            margin-top: 10px;
        }

        #fallback-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            background-color: #111624;
            color: #ffffff;
            z-index: 5;
            overflow: auto;
            display: none;
        }

        .fallback-button {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #3d8a3d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .fallback-button:hover {
            background-color: #2d682d;
        }

        /* Value display panel */
        .value-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(20, 27, 44, 0.85);
            border: 1px solid #2a3c54;
            border-radius: 4px;
            padding: 10px;
            font-size: 14px;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .value-display p {
            margin: 5px 0;
        }

        /* Guide panel */
        .guide-panel {
            background-color: #1a2235;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .guide-panel h3 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .guide-panel p {
            font-size: 14px;
            color: #aabbcc;
        }

        /* Formula section styling */
        .formula-section {
            margin-top: 20px;
        }

        .formulas {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .formula {
            background-color: #1e293e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .formula h4 {
            border-bottom: 1px solid #2a3c54;
            padding-bottom: 8px;
            margin-bottom: 10px;
            color: #ffffff;
            font-size: 16px;
        }

        .formula p {
            margin: 8px 0;
            color: #aabbcc;
            font-size: 14px;
            line-height: 1.6;
        }

        .formula-notes {
            grid-column: 1 / -1;
            background-color: #1e293e;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .formula-notes ul {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            list-style-type: none;
            padding-left: 0;
            margin-top: 10px;
        }

        .formula-notes li {
            color: #aabbcc;
            font-size: 14px;
            padding-left: 15px;
            position: relative;
        }

        .formula-notes li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #4f8fff;
        }

        /* MathJax styling for dark theme */
        .MathJax {
            color: #ffffff !important;
        }

        .formula .MathJax {
            font-size: 120% !important;
        }

        .formula .MJX-TEX .mjx-frac {
            font-size: 130% !important;
            vertical-align: -0.5em;
        }

        .formula .MJX-TEX .mjx-num {
            padding-bottom: 0.2em;
        }

        .formula .MJX-TEX .mjx-den {
            padding-top: 0.2em;
            border-top-width: 2px;
        }

        /* LinkedIn link styling */
        .linkedin-link {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            transition: transform 0.2s;
        }

        .linkedin-link:hover {
            transform: scale(1.1);
        }

        /* Footer styling */
        .footer {
            margin-top: 20px;
            padding: 15px 0;
            text-align: center;
            border-top: 1px solid #2a3c54;
        }

        .footer p {
            font-size: 14px;
            color: #aabbcc;
        }

        .footer a {
            color: #4f8fff;
            text-decoration: none;
            transition: color 0.2s;
        }

        .footer a:hover {
            color: #7fafff;
            text-decoration: underline;
        }

        /* Responsive adjustments */
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            
            .controls-panel {
                width: 100%;
            }

            .linkedin-link {
                top: 10px;
                right: 10px;
            }
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="container">
        <h1>Black-Scholes Greeks 3D Visualization</h1>
        
        <div class="main-content">
            <!-- Controls -->
            <div class="controls-panel">
                <div class="control-group">
                    <label for="greekSelect">Greek</label>
                    <select id="greekSelect" class="control-input">
                        <option value="delta">Delta (Δ)</option>
                        <option value="vega">Vega (ν)</option>
                        <option value="theta">Theta (Θ)</option>
                        <option value="gamma">Gamma (Γ)</option>
                        <option value="vanna">Vanna</option>
                        <option value="charm">Charm</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="optionTypeSelect">Option Type</label>
                    <select id="optionTypeSelect" class="control-input">
                        <option value="call">Call</option>
                        <option value="put">Put</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="positionTypeSelect">Position</label>
                    <select id="positionTypeSelect" class="control-input">
                        <option value="long">Long</option>
                        <option value="short">Short</option>
                    </select>
                    <div class="control-group">
                        <label for="daysToExpiryInput">Days to Expiry</label>
                        <input type="number" id="daysToExpiryInput" class="control-input" value="1" min="0.000001" max="10000" step="1">
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>Parameters</h3>
                    <ul>
                        <li>standard normal distribution</li>
                        <li>Spot (S): 6000</li>
                        <li>Strike (K): 5800-6200 in steps of 5</li>
                        <li>Interest Rate (r): 0.03</li>
                        <li>Dividend Yield (q): 0.00001</li>
                        <li>Time to Expiry (τ): Input/365 </li>
                        <li>IV: 0.10-0.90 in steps of 0.01</li>
                        <li>Vanna is devided by 100</li>
                        <li>Theta and charm are multiplied by 1/251</li>
                    </ul>
                </div>
                
                <div class="info-panel">
                    <h3>Navigation</h3>
                    <ul>
                        <li>Click and drag to rotate</li>
                        <li>Scroll to zoom in/out</li>
                        <li>Right-click and drag to pan</li>
                    </ul>
                </div>
            </div>
            
            <!-- 3D Plot -->
            <div class="visualization-container">
                <div id="loading">
                    <div class="loading-spinner"></div>
                    <div>Initializing 3D visualization...</div>
                    <div class="loading-tips">This may take a few moments for the first load</div>
                </div>
                <div id="plotContainer"></div>
                <div id="value-display" class="value-display">
                    <h3>Position Information</h3>
                    <p><strong>Strike:</strong> <span id="strike-value">-</span></p>
                    <p><strong>IV:</strong> <span id="iv-value">-</span></p>
                    <p><strong>Greek Value:</strong> <span id="greek-value">-</span></p>
                </div>
                <div id="fallback-container">
                    <h3>3D Visualization Not Available</h3>
                    <p>The 3D visualization couldn't be loaded. This might be due to:</p>
                    <ul>
                        <li>WebGL not being supported by your browser</li>
                        <li>Insufficient system resources</li>
                        <li>Browser extensions blocking JavaScript</li>
                    </ul>
                    <p>Try the following:</p>
                    <ul>
                        <li>Use a modern browser like Chrome, Firefox, or Edge</li>
                        <li>Disable hardware acceleration in your browser settings</li>
                        <li>Close other tabs and applications to free up memory</li>
                        <li>Try the 2D visualization option</li>
                    </ul>
                    <button id="show2DButton" class="fallback-button">Switch to 2D View</button>
                </div>
            </div>
        </div>
        
        <div class="guide-panel">
            <h3>Visualization Guide</h3>
            <p>
                This 3D plot shows how the selected option Greek varies with both Strike Price (K) and 
                Implied Volatility (IV). The x-axis represents Strike Price, the y-axis shows the Greek value, 
                and the z-axis represents Implied Volatility. The lines along the curves highlight each strike
                price across different IV levels. Hover over the surface to see exact values.
            </p>
            <div class="guide-panel formula-section">
                <h3>Option Greeks Formulas</h3>
                <div class="formulas">
                  <div class="formula">
                    <h4>Delta (Δ)</h4>
                    <p>Call: \(e^{-qT} N(d_1)\)</p>
                    <p>Put: \(-e^{-qT} N(-d_1)\)</p>
                  </div>
                  
                  <div class="formula">
                    <h4>Gamma (Γ)</h4>
                    <p>Call/Put: \(\frac{e^{-qT} N'(d_1)}{S\sigma\sqrt{T}}\)</p>
                  </div>
                  
                  <div class="formula">
                    <h4>Vega (ν)</h4>
                    <p>Call/Put: \(S e^{-qT} N'(d_1) \sqrt{T}\)</p>
                  </div>
                  
                  <div class="formula">
                    <h4>Vanna</h4>
                    <p>Call/Put: \(-e^{-qT} N'(d_1) \frac{d_2}{\sigma}\)</p>
                  </div>
                  
                  <div class="formula">
                    <h4>Charm</h4>
                    <p>Call: \(qe^{-qT}N(d_1) - e^{-qT}N'(d_1)\frac{2(r-q)T - d_2\sigma\sqrt{T}}{2T\sigma\sqrt{T}}\)</p>
                    <p>Put: \(-qe^{-qT}N(-d_1) - e^{-qT}N'(d_1)\frac{2(r-q)T - d_2\sigma\sqrt{T}}{2T\sigma\sqrt{T}}\)</p>
                  </div>
                  
                  <div class="formula">
                    <h4>Theta (Θ)</h4>
                    <p>Call: \(-\frac{S e^{-qT} N'(d_1) \sigma}{2\sqrt{T}} - rKe^{-rT}N(d_2) + qSe^{-qT}N(d_1)\)</p>
                    <p>Put: \(-\frac{S e^{-qT} N'(d_1) \sigma}{2\sqrt{T}} + rKe^{-rT}N(-d_2) - qSe^{-qT}N(-d_1)\)</p>
                  </div>
                  
                  <div class="formula-notes">
                    <p><strong>Where:</strong></p>
                    <ul>
                      <li>\(d_1 = \frac{\ln(S/K) + (r - q + \sigma^2/2)T}{\sigma\sqrt{T}}\)</li>
                      <li>\(d_2 = d_1 - \sigma\sqrt{T}\)</li>
                      <li>\(N(x)\) is the standard normal CDF</li>
                      <li>\(N'(x)\) is the standard normal PDF</li>
                      <li>\(S\) is the spot price</li>
                      <li>\(K\) is the strike price</li>
                      <li>\(r\) is the risk-free rate</li>
                      <li>\(q\) is the dividend yield</li>
                      <li>\(\sigma\) is the volatility</li>
                      <li>\(T\) is the time to expiry</li>
                    </ul>
                  </div>
                </div>
              </div>
              <div class="footer">
                <p>Created by <a href="https://www.linkedin.com/in/johannes-dassler-19473b225/" target="_blank" rel="noopener noreferrer">Johannes Dassler</a></p>
              </div>
        </div>
        <a href="https://www.linkedin.com/in/johannes-dassler-19473b225/" target="_blank" rel="noopener noreferrer" class="linkedin-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#4f8fff">
                <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
            </svg>
        </a>
    </div>
    
    <script>
        // Constants for the Black-Scholes model
        const DEFAULT_SPOT = 6000;
        const DEFAULT_RATE = 0.03;
        const DEFAULT_DIVIDEND = 0.00001;
        
        // DOM elements
        const daysToExpiryInput = document.getElementById('daysToExpiryInput');
        const greekSelect = document.getElementById('greekSelect');
        const optionTypeSelect = document.getElementById('optionTypeSelect');
        const positionTypeSelect = document.getElementById('positionTypeSelect');
        const plotContainer = document.getElementById('plotContainer');
        const loadingElement = document.getElementById('loading');
        const fallbackContainer = document.getElementById('fallback-container');
        const show2DButton = document.getElementById('show2DButton');
        const valueDisplay = document.getElementById('value-display');
        const strikeValueElement = document.getElementById('strike-value');
        const ivValueElement = document.getElementById('iv-value');
        const greekValueElement = document.getElementById('greek-value');

        // Three.js variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let meshes = [];
        let surfaceMesh;
        let gridGroup;
        let strikeLines = [];
        let strikeData = {};

        // Fallback mode flag
        let use2DMode = false;
        let initializationAttempted = false;
        let initializationTimeout;

        // Check WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!(
                    window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
                );
            } catch (e) {
                return false;
            }
        }

        // Show fallback UI if WebGL or Three.js fails
        function showFallbackUI(message) {
            console.error(message);
            loadingElement.style.display = 'none';
            fallbackContainer.style.display = 'block';
            
            show2DButton.addEventListener('click', function() {
                use2DMode = true;
                fallbackContainer.style.display = 'none';
                init2DMode();
            });
        }

        // Initialize 2D mode (simplified visualization)
        function init2DMode() {
            plotContainer.innerHTML = '';
            plotContainer.style.display = 'flex';
            plotContainer.style.flexDirection = 'column';
            plotContainer.style.alignItems = 'center';
            plotContainer.style.justifyContent = 'center';
            plotContainer.style.padding = '20px';
            valueDisplay.style.display = 'none';
            
            const title = document.createElement('h3');
            title.textContent = `${getGreekDisplayName(greekSelect.value)} for ${positionTypeSelect.value} ${optionTypeSelect.value} options`;
            title.style.color = '#ffffff';
            plotContainer.appendChild(title);
            
            // Create line chart using canvas
            const canvas = document.createElement('canvas');
            canvas.width = plotContainer.clientWidth - 40;
            canvas.height = 400;
            plotContainer.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            draw2DChart(ctx, canvas.width, canvas.height);
            
            // Add legend
            const legend = document.createElement('div');
            legend.style.display = 'flex';
            legend.style.flexWrap = 'wrap';
            legend.style.marginTop = '20px';
            legend.style.justifyContent = 'center';
            legend.style.color = '#ffffff';
            
            [5800, 5900, 6000, 6100, 6200].forEach(strike => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.margin = '0 10px 10px 0';
                
                const color = document.createElement('div');
                color.style.width = '20px';
                color.style.height = '3px';
                color.style.backgroundColor = getColorForStrike(strike);
                color.style.marginRight = '5px';
                
                const label = document.createElement('span');
                label.textContent = `Strike ${strike}`;
                
                item.appendChild(color);
                item.appendChild(label);
                legend.appendChild(item);
            });
            
            plotContainer.appendChild(legend);
            
            // Add event listener for controls
            greekSelect.addEventListener('change', () => init2DMode());
            optionTypeSelect.addEventListener('change', () => init2DMode());
            positionTypeSelect.addEventListener('change', () => init2DMode());
        }

        // Draw 2D chart on canvas (simplified visualization)
        function draw2DChart(ctx, width, height) {
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            
            // Fill dark background
            ctx.fillStyle = '#111624';
            ctx.fillRect(0, 0, width, height);
            
            // Generate data (simplified for 2D)
            const strikes = [];
            for (let strike = 5800; strike <= 6200; strike += 25) {
                strikes.push(strike);
            }
            
            const ivValues = [];
            for (let iv = 0.1; iv <= 0.9; iv += 0.05) {
                ivValues.push(iv);
            }
            
            // Find min/max values for scaling
            let minValue = Infinity;
            let maxValue = -Infinity;
            
            strikes.forEach(strike => {
                ivValues.forEach(iv => {
                    const value = getGreekValue(DEFAULT_SPOT, strike, iv);
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                });
            });
            
            // Add some padding to min/max
            const valuePadding = (maxValue - minValue) * 0.1;
            minValue -= valuePadding;
            maxValue += valuePadding;
            
            // Draw grid
            ctx.strokeStyle = '#2a3c54';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = height - padding - (i / 5) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let i = 0; i <= ivValues.length; i += 2) {
                const x = padding + (i / ivValues.length) * chartWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#4f8fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            // X-axis (IV)
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            
            // Y-axis (Greek value)
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(padding, padding);
            
            ctx.stroke();
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            
            ivValues.forEach((iv, index) => {
                if (index % 2 === 0) { // Show every other label to avoid crowding
                    const x = padding + (index / (ivValues.length - 1)) * chartWidth;
                    ctx.fillText(iv.toFixed(2), x, height - padding + 5);
                }
            });
            
            // Draw Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i <= 5; i++) {
                const value = minValue + (i / 5) * (maxValue - minValue);
                const y = height - padding - (i / 5) * chartHeight;
                ctx.fillText(value.toFixed(4), padding - 5, y);
            }
            
            // Draw axis titles
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Implied Volatility (IV)', width / 2, height - 5);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textBaseline = 'top';
            ctx.fillText(getGreekDisplayName(greekSelect.value), 0, 0);
            ctx.restore();
            
            // Draw lines for each strike price
            strikes.forEach(strike => {
                const points = [];
                
                ivValues.forEach(iv => {
                    const value = getGreekValue(DEFAULT_SPOT, strike, iv);
                    const x = padding + ((iv - 0.1) / 0.8) * chartWidth;
                    const y = height - padding - ((value - minValue) / (maxValue - minValue)) * chartHeight;
                    points.push({x, y});
                });
                
                // Draw line with green coloring similar to reference
                const strikePct = (strike - 5800) / 400; // Normalized 0-1
                const green = 128 + Math.round(strikePct * 127);
                ctx.strokeStyle = `rgb(51, ${green}, 102)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.stroke();
            });
        }

        // Error function implementation (for standard normal CDF)
        function erf(x) {
            // Constants
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            // Save the sign
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            
            // Approximation formula
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }

        // Standard normal CDF (Cumulative Distribution Function)
        function normCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        // Standard normal PDF (Probability Density Function)
        function normPDF(x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }

        // Calculate d1 and d2 for Black-Scholes
        function calculateDs(S, K, r, q, sigma, T) {
            const d1 = (Math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
            const d2 = d1 - sigma * Math.sqrt(T);
            return { d1, d2 };
        }

        // Calculate Call option price and Greeks
        function calculateCallOption(S, K, r, q, sigma, T) {
            const { d1, d2 } = calculateDs(S, K, r, q, sigma, T);
            
            // Using the formulas provided in the original request
            const price = S * Math.exp(-q * T) * normCDF(d1) - K * Math.exp(-r * T) * normCDF(d2);
            const delta = Math.exp(-q * T) * normCDF(d1);
            const gamma = Math.exp(-q * T) * normPDF(d1) / (S * sigma * Math.sqrt(T));
            const vega = S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T);
            const vanna = (-Math.exp(-q * T) * normPDF(d1) * (d2 / sigma))/100;
            const charm = (q * Math.exp(-q * T) * normCDF(d1) - Math.exp(-q * T) * normPDF(d1) * 
                        (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T)))/251;
            const theta = -(((S * Math.exp(-q * T) * normPDF(d1) * sigma) / (2 * Math.sqrt(T))) - 
              (r * K * Math.exp(-r * T) * normCDF(d2)) + 
              (q * S * Math.exp(-q * T) * normCDF(d1)))/251;
            
            return { price, delta, gamma, vega, vanna, charm, theta };
        }

        // Calculate Put option price and Greeks
        function calculatePutOption(S, K, r, q, sigma, T) {
            const { d1, d2 } = calculateDs(S, K, r, q, sigma, T);
            
            const price = K * Math.exp(-r * T) * normCDF(-d2) - S * Math.exp(-q * T) * normCDF(-d1);
            const delta = -Math.exp(-q * T) * normCDF(-d1);
            const gamma = Math.exp(-q * T) * normPDF(d1) / (S * sigma * Math.sqrt(T));
            const vega = S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T);
            const vanna = (-Math.exp(-q * T) * normPDF(d1) * (d2 / sigma))/100;
            const charm = (-q * Math.exp(-q * T) * normCDF(-d1) - Math.exp(-q * T) * normPDF(d1) * 
                        (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T)))/251;
            const theta = -(((S * Math.exp(-q * T) * normPDF(d1) * sigma) / (2 * Math.sqrt(T))) + 
              (r * K * Math.exp(-r * T) * normCDF(-d2)) - 
              (q * S * Math.exp(-q * T) * normCDF(-d1)))/251;
            
            return { price, delta, gamma, vega, vanna, charm, theta };
        }

        // Helper function to get the selected Greek value based on option type and position
        function getGreekValue(S, K, iv) {
            const greek = greekSelect.value;
            const optionType = optionTypeSelect.value;
            const positionType = positionTypeSelect.value;
            
            // Use the days to expiry input to calculate T
            const daysToExpiry = parseFloat(daysToExpiryInput.value) || 1; // Default to 1 if invalid
            const T = daysToExpiry / 365; // Trading days in a year
            
            const calculation = optionType === 'call' 
                ? calculateCallOption(S, K, DEFAULT_RATE, DEFAULT_DIVIDEND, iv, T)
                : calculatePutOption(S, K, DEFAULT_RATE, DEFAULT_DIVIDEND, iv, T);
            
            let value = calculation[greek];
            
            // Adjust for short positions (negative value)
            if (positionType === 'short') {
                value = -value;
            }
            
            return value;
        }

        // Generate data with reduced complexity for faster initial loading
        function generateReducedData(initialLoad) {
            // For initial load, use a reduced data set
            const strikeStep = initialLoad ? 10 : 5;  // Smaller steps for more detail
            const ivStep = initialLoad ? 0.05 : 0.02; // Larger steps for initial load
            
            const data = [];
            
            // Clear strike data object
            strikeData = {};
            
            // Strike prices from 5800 to 6200 in smaller steps
            for (let strike = 5800; strike <= 6200; strike += strikeStep) {
                const strikeDataPoints = [];
                
                // IV values from 0.10 to 0.90 in steps
                for (let iv = 0.10; iv <= 0.90; iv += ivStep) {
                    const greekValue = getGreekValue(DEFAULT_SPOT, strike, iv);
                    strikeDataPoints.push({
                        strike,
                        iv,
                        value: greekValue
                    });
                }
                
                data.push(strikeDataPoints);
                
                // Store data by strike price for drawing strike lines
                strikeData[strike] = strikeDataPoints;
            }
            
            return data;
        }

        // Generate color based on value (for surface coloring)
        function getColorForValue(value, min, max) {
            // Normalize value to 0-1 range
            const normalized = (value - min) / (max - min);
            
            // Red to green gradient
            let r = 1 - normalized;
            let g = normalized;
            let b = 0.1;
            
            // Convert to RGB color
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }

        // Map Greek names to display names
        function getGreekDisplayName(greek) {
            const greekMap = {
                'delta': 'Delta (Δ)',
                'gamma': 'Gamma (Γ)',
                'vega': 'Vega (ν)',
                'vanna': 'Vanna',
                'charm': 'Charm',
                'theta': 'Theta (Θ)'
            };
            return greekMap[greek] || greek;
        }

        // Create text sprite without background, with larger text
        function createTextSprite(text, parameters) {
            if (parameters === undefined) parameters = {};
            
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize ? parameters.fontsize * 1.5 : 36; 
            const textColor = parameters.textColor || { r:1.0, g:1.0, b:1.0, a:1.0 };
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            canvas.width = 768;
            canvas.height = 384;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.font = "Bold " + fontsize + "px " + fontface;
            
            context.fillStyle = "rgba(" + textColor.r * 255 + "," + textColor.g * 255 + ","
                                        + textColor.b * 255 + "," + textColor.a + ")";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true 
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            const textWidth = context.measureText(text).width;
            sprite.scale.set(textWidth/6 + 50, 50, 1.0);
            
            return sprite;
        }

        // Set up enhanced lighting for dark theme visualization
        function setupLighting() {
            // Remove any existing lights
            scene.children.forEach(child => {
                if (child.isLight) scene.remove(child);
            });
            
            // Add ambient light for dark background
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.7);
            scene.add(ambientLight);
            
            // Add directional light with slight blue tint
            const directionalLight = new THREE.DirectionalLight(0xb4c2ff, 1.2);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add secondary light source for better highlights
            const secondaryLight = new THREE.DirectionalLight(0xaaffcc, 0.5);
            secondaryLight.position.set(-1, 0.5, -1);
            scene.add(secondaryLight);
        }

        // Get color for a specific strike price
        function getColorForStrike(strike) {
            // Map strike price to a color using a gradient
            const minStrike = 5800;
            const maxStrike = 6200;
            const t = (strike - minStrike) / (maxStrike - minStrike);
            
            // Red to green gradient for strike prices
            return new THREE.Color(1 - t, t, 0.1);
        }

        // Initialize Three.js scene
        function init() {
            try {
                initializationAttempted = true;
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111624);
                
                // Create camera
                const aspect = plotContainer.clientWidth / plotContainer.clientHeight;
                camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 2000);
                camera.position.set(0, 0, -600);
                camera.lookAt(0, 0, 0);
                
                // Create renderer with higher quality
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    precision: 'highp',
                    powerPreference: 'high-performance'
                });
                renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
                plotContainer.appendChild(renderer.domElement);
                
                // Set up enhanced lighting for dark theme
                setupLighting();
                
                // Add orbit controls
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.rotateSpeed = 0.5;
                } else {
                    throw new Error("OrbitControls not loaded");
                }
                
                // Create grid group
                gridGroup = new THREE.Group();
                scene.add(gridGroup);
                
                // Initialize raycaster for interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Add mouse move event listener for interaction
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                
                // Create initial plot with reduced data
                setTimeout(() => {
                    updatePlot(true); // true for reduced data set on initial load
                    
                    // Start animation
                    animate();
                    
                    // Clear the initialization timeout since we've successfully initialized
                    clearTimeout(initializationTimeout);
                }, 10);
                
            } catch (err) {
                clearTimeout(initializationTimeout);
                showFallbackUI("Error initializing 3D visualization. Switching to 2D mode.");
            }
        }

        // Mouse move handler for interaction
        function onMouseMove(event) {
            if (use2DMode || !surfaceMesh) return;
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        // Update value display based on raycaster intersection
        function updateValueDisplay() {
            if (!raycaster || !camera || !surfaceMesh || !mouse) return;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObject(surfaceMesh);
            
            if (intersects.length > 0) {
                // Get position data from the closest intersection
                const intersection = intersects[0];
                const face = intersection.face;
                const geometry = surfaceMesh.geometry;
                
                // Get vertex indices
                const a = face.a;
                
                // Get attributes from vertices
                const positions = geometry.attributes.position;
                
                // Calculate barycentric coordinates to get exact values at intersection
                const baryCoord = intersection.barycoord || { x: 1/3, y: 1/3, z: 1/3 };
                
                // Variables for holding our extracted values
                const gridSize = 150;
                const strikeRange = 6200 - 5800;
                const ivRange = 0.9 - 0.1;
                
                // Calculate the nearest data point to the intersection
                const vertexIndex = a; // Use one of the vertices of the face
                
                // Extract data based on position (convert from scene coordinates back to data values)
                let strike, iv, value;
                
                // Convert coordinates back to data values
                const x = positions.getX(vertexIndex);
                const y = positions.getY(vertexIndex);
                const z = positions.getZ(vertexIndex);
                
                // Account for inverted X-axis scale in conversion
                strike = Math.round((-x / gridSize) * strikeRange/2 + 6000);
                iv = ((z / gridSize) * ivRange/2 + 0.5).toFixed(2);
                
                // Use pre-calculated value for the Greek
                value = getGreekValue(DEFAULT_SPOT, strike, parseFloat(iv)).toFixed(4);
                
                // Update value display
                strikeValueElement.textContent = strike;
                ivValueElement.textContent = iv;
                greekValueElement.textContent = value;
            } else {
                // No intersection, show default values
                strikeValueElement.textContent = '-';
                ivValueElement.textContent = '-';
                greekValueElement.textContent = '-';
            }
        }

        // Animation loop
        function animate() {
            if (use2DMode) return; // Don't animate in 2D mode
            
            requestAnimationFrame(animate);
            if (controls) controls.update();
            
            // Update value display based on mouse position
            updateValueDisplay();
            
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        // Update the 3D plot
        function updatePlot(initialLoad = false) {
            try {
                loadingElement.style.display = 'flex';
                loadingElement.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Generating visualization...</div>
                    <div class="loading-tips">This may take a few moments</div>
                `;
                
                // Clear previous meshes
                meshes.forEach(mesh => {
                    if (scene) {
                        scene.remove(mesh);
                        // Clean up resources
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(material => material.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    }
                });
                meshes = [];
                
                // Clear grid group
                if (gridGroup) {
                    while(gridGroup.children.length > 0) {
                        const child = gridGroup.children[0];
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(material => material.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                        gridGroup.remove(child);
                    }
                }
                
                // Clear strike lines
                strikeLines.forEach(line => {
                    if (scene) {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    }
                });
                strikeLines = [];
                
                // Generate new data
                const surfaceData = generateReducedData(initialLoad);
                
                // Find min/max values for scaling
                let minValue = Infinity;
                let maxValue = -Infinity;
                
                surfaceData.forEach(strikePoints => {
                    strikePoints.forEach(point => {
                        minValue = Math.min(minValue, point.value);
                        maxValue = Math.max(maxValue, point.value);
                    });
                });
                
                // Create reference grid with labels
                createBackgroundGrid(minValue, maxValue);
                
                // Scaling factors for better visualization
                const gridSize = 150;
                const strikeRange = 6200 - 5800;
                const ivRange = 0.9 - 0.1;
                const valueRange = maxValue - minValue || 1; // Avoid division by zero
                
                // Use negative scaleX to invert the X-axis
                const scaleX = -gridSize / (strikeRange/2);
                const scaleY = gridSize / (valueRange/2);
                const scaleZ = gridSize / (ivRange/2);
                
                // Offset to center the plot
                const offsetX = -6000;
                const offsetY = -(minValue + maxValue) / 2;
                const offsetZ = -0.5;
                
                loadingElement.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Creating visualization...</div>
                    <div class="loading-tips">Almost there!</div>
                `;
                
                // Create surface geometry
                const geometrySurface = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const indices = [];
                
                // Create surface mesh vertices
                const rows = surfaceData.length;
                const cols = surfaceData[0]?.length || 0;
                
                // Create vertices and vertex colors
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const point = surfaceData[i][j];
                        const x = (point.strike + offsetX) * scaleX;
                        const y = (point.value + offsetY) * scaleY;
                        const z = (point.iv + offsetZ) * scaleZ;
                        
                        vertices.push(x, y, z);
                        
                        // Color based on the value
                        const color = getColorForValue(point.value, minValue, maxValue);
                        const rgb = color.match(/\d+/g).map(Number);
                        
                        colors.push(rgb[0]/255, rgb[1]/255, rgb[2]/255);
                    }
                }
                
                // Create faces (triangles) for the surface
                for (let i = 0; i < rows - 1; i++) {
                    for (let j = 0; j < cols - 1; j++) {
                        const a = i * cols + j;
                        const b = i * cols + (j + 1);
                        const c = (i + 1) * cols + j;
                        const d = (i + 1) * cols + (j + 1);
                        
                        // First triangle
                        indices.push(a, c, b);
                        
                        // Second triangle
                        indices.push(b, c, d);
                    }
                }
                
                geometrySurface.setIndex(indices);
                geometrySurface.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometrySurface.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometrySurface.computeVertexNormals();
                
                // Enhanced material for better appearance on dark background
                const materialSurface = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    shininess: 70,
                    flatShading: false,
                    transparent: false,
                    depthWrite: true
                });
                
                surfaceMesh = new THREE.Mesh(geometrySurface, materialSurface);
                scene.add(surfaceMesh);
                meshes.push(surfaceMesh);
                
                // Add lines along the strike curves (one line for each strike)
                addStrikeLines(minValue, maxValue);
                
                // Add title and axis labels
                addAxisLabels(minValue, maxValue);
                
                loadingElement.style.display = 'none';
                valueDisplay.style.display = 'block';
                
                // If this was the initial load with reduced data, schedule a full update
                if (initialLoad) {
                    const fullUpdateMessage = document.createElement('div');
                    fullUpdateMessage.textContent = "Loading full resolution data...";
                    fullUpdateMessage.style.position = 'absolute';
                    fullUpdateMessage.style.bottom = '10px';
                    fullUpdateMessage.style.right = '10px';
                    fullUpdateMessage.style.background = 'rgba(25, 30, 45, 0.7)';
                    fullUpdateMessage.style.padding = '5px 10px';
                    fullUpdateMessage.style.borderRadius = '4px';
                    fullUpdateMessage.style.fontSize = '12px';
                    fullUpdateMessage.style.color = '#ffffff';
                    plotContainer.appendChild(fullUpdateMessage);
                    
                    // Schedule full data update after 2 seconds
                    setTimeout(() => {
                        updatePlot(false);
                        fullUpdateMessage.remove();
                    }, 2000);
                }
                
            } catch (err) {
                loadingElement.innerHTML = `
                    <div>Error generating visualization</div>
                    <div class="loading-tips">Try refreshing the page or use 2D mode</div>
                    <button id="error2DButton" class="fallback-button">Switch to 2D Mode</button>
                `;
                loadingElement.style.display = 'flex';
                
                // Add event listener for 2D switch button
                document.getElementById('error2DButton').addEventListener('click', function() {
                    use2DMode = true;
                    init2DMode();
                    loadingElement.style.display = 'none';
                });
            }
        }
        
        // Add lines along each strike price curve
        function addStrikeLines(minValue, maxValue) {
            // Use more strike prices to highlight with smaller steps
            const keyStrikes = [];
            for (let strike = 5800; strike <= 6200; strike += 20) {
                keyStrikes.push(strike);
            }
            
            const gridSize = 150;
            const strikeRange = 6200 - 5800;
            const ivRange = 0.9 - 0.1;
            const valueRange = maxValue - minValue || 1;
            
            // Use negative scaleX to invert the X-axis
            const scaleX = -gridSize / (strikeRange/2);
            const scaleY = gridSize / (valueRange/2);
            const scaleZ = gridSize / (ivRange/2);
            
            const offsetX = -6000;
            const offsetY = -(minValue + maxValue) / 2;
            const offsetZ = -0.5;
            
            // Create a line for each strike price
            keyStrikes.forEach(strike => {
                if (!strikeData[strike]) return; // Skip if no data for this strike
                
                const points = strikeData[strike];
                const linePoints = [];
                
                // Convert data points to 3D coordinates
                points.forEach(point => {
                    const x = (point.strike + offsetX) * scaleX;
                    const y = (point.value + offsetY) * scaleY;
                    const z = (point.iv + offsetZ) * scaleZ;
                    
                    linePoints.push(new THREE.Vector3(x, y, z));
                });
                
                // Create line geometry
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                
                // Create line material
                const color = getColorForStrike(strike);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    linewidth: 3,
                    transparent: false,
                    opacity: 1.0
                });
                
                // Create line and add to scene
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
                strikeLines.push(line);
                
                // Add strike labels only for every 100 points to avoid clutter
                if (strike % 100 === 0) {
                    // Use the last point (back of graph)
                    const lastPoint = linePoints[linePoints.length - 1]; 
                    
                    const strikeLabel = createTextSprite(strike.toString(), {
                        fontsize: 30,
                        textColor: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
                    });
                    
                    strikeLabel.position.set(lastPoint.x - 10, lastPoint.y, lastPoint.z);
                    strikeLabel.scale.set(120, 60, 1.0);
                    scene.add(strikeLabel);
                    strikeLines.push(strikeLabel);
                }
            });
        }
        
        // Create a background grid with labeled axes
        function createBackgroundGrid(minValue, maxValue) {
            const gridSize = 150;
            
            // Create grid container
            const container = new THREE.Object3D();
            gridGroup.add(container);
            
            // Material with depthWrite = false to ensure grid is always visible
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.4,
                depthWrite: false,
                depthTest: true,
                linewidth: 1.5
            });
            
            // Denser grid
            const minorGridStep = 15; 
            
            // XZ Plane (bottom)
            const xzGridGeometry = new THREE.BufferGeometry();
            const xzVertices = [];
            
            // X lines
            for (let x = -gridSize; x <= gridSize; x += minorGridStep) {
                xzVertices.push(x, 0, -gridSize, x, 0, gridSize);
            }
            
            // Z lines
            for (let z = -gridSize; z <= gridSize; z += minorGridStep) {
                xzVertices.push(-gridSize, 0, z, gridSize, 0, z);
            }
            
            xzGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(xzVertices, 3));
            const xzGrid = new THREE.LineSegments(xzGridGeometry, gridMaterial);
            container.add(xzGrid);
            
            // XY Plane (back wall)
            const xyGridGeometry = new THREE.BufferGeometry();
            const xyVertices = [];
            
            // X lines
            for (let x = -gridSize; x <= gridSize; x += minorGridStep) {
                xyVertices.push(x, -gridSize, gridSize, x, gridSize, gridSize);
            }
            
            // Y lines
            for (let y = -gridSize; y <= gridSize; y += minorGridStep) {
                xyVertices.push(-gridSize, y, gridSize, gridSize, y, gridSize);
            }
            
            xyGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(xyVertices, 3));
            const xyGrid = new THREE.LineSegments(xyGridGeometry, gridMaterial);
            container.add(xyGrid);
            
            // YZ Plane (left wall)
            const yzGridGeometry = new THREE.BufferGeometry();
            const yzVertices = [];
            
            // Y lines
            for (let y = -gridSize; y <= gridSize; y += minorGridStep) {
                yzVertices.push(-gridSize, y, -gridSize, -gridSize, y, gridSize);
            }
            
            // Z lines
            for (let z = -gridSize; z <= gridSize; z += minorGridStep) {
                yzVertices.push(-gridSize, -gridSize, z, -gridSize, gridSize, z);
            }
            
            yzGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(yzVertices, 3));
            const yzGrid = new THREE.LineSegments(yzGridGeometry, gridMaterial);
            container.add(yzGrid);
            
            // Axes with brighter color
            const axesMaterial = new THREE.LineBasicMaterial({ 
                color: 0x4f8fff,
                linewidth: 2,
                transparent: false,
                opacity: 1.0
            });
            
            // X-axis - at maximum Z (back)
            const xAxisGeometry = new THREE.BufferGeometry();
            const xAxisVertices = new Float32Array([
                -gridSize, 0, gridSize,
                gridSize, 0, gridSize
            ]);
            xAxisGeometry.setAttribute('position', new THREE.BufferAttribute(xAxisVertices, 3));
            const xAxis = new THREE.Line(xAxisGeometry, axesMaterial);
            container.add(xAxis);
            
            // Y-axis - at maximum Z (back)
            const yAxisGeometry = new THREE.BufferGeometry();
            const yAxisVertices = new Float32Array([
                -gridSize, -gridSize, gridSize,
                -gridSize, gridSize, gridSize
            ]);
            yAxisGeometry.setAttribute('position', new THREE.BufferAttribute(yAxisVertices, 3));
            const yAxis = new THREE.Line(yAxisGeometry, axesMaterial);
            container.add(yAxis);
            
            // Z-axis
            const zAxisGeometry = new THREE.BufferGeometry();
            const zAxisVertices = new Float32Array([
                -gridSize, 0, -gridSize,
                -gridSize, 0, gridSize
            ]);
            zAxisGeometry.setAttribute('position', new THREE.BufferAttribute(zAxisVertices, 3));
            const zAxis = new THREE.Line(zAxisGeometry, axesMaterial);
            container.add(zAxis);
            
            // White text for axis labels on dark background
            const axisLabelFontSize = 30;
            const axisLabelScale = new THREE.Vector3(120, 60, 1.0);
            const textColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
            
            // Strike (X-axis) labels - inverted order and at foreground
            const strikeValues = [6200, 6100, 6000, 5900, 5800];
            const strikePositions = [-gridSize * 0.8, -gridSize * 0.4, 0, gridSize * 0.4, gridSize * 0.8];
            
            strikePositions.forEach((pos, index) => {
                const label = createTextSprite(strikeValues[index].toString(), {
                    fontsize: axisLabelFontSize,
                    textColor: textColor
                });
                label.position.set(pos, -15, -gridSize - 15);
                label.scale.copy(axisLabelScale);
                container.add(label);
            });
            
            // IV (Z-axis) labels
            const ivValues = [0.1, 0.3, 0.5, 0.7, 0.9];
            const ivPositions = [-gridSize * 0.8, -gridSize * 0.4, 0, gridSize * 0.4, gridSize * 0.8];
            
            ivPositions.forEach((pos, index) => {
                const label = createTextSprite(ivValues[index].toFixed(1), {
                    fontsize: axisLabelFontSize,
                    textColor: textColor
                });
                label.position.set(-gridSize - 15, -15, pos);
                label.scale.copy(axisLabelScale);
                container.add(label);
            });
            
            // Greek value (Y-axis) labels - at foreground (minimum Z)
            const valueStep = (maxValue - minValue) / 4;
            for (let i = 0; i <= 4; i++) {
                const value = minValue + i * valueStep;
                const position = -gridSize + i * gridSize / 2;
                
                const label = createTextSprite(value.toFixed(3), {
                    fontsize: axisLabelFontSize,
                    textColor: textColor
                });
                label.position.set(-gridSize - 25, position, -gridSize - 15);
                label.scale.copy(axisLabelScale);
                container.add(label);
            }
        }

        // Add title and main axis labels
        function addAxisLabels(minValue, maxValue) {
            const gridSize = 150;
            const textColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
            
            // X Label
            const xLabel = createTextSprite("Strike Price (K)", {
                fontsize: 24,
                textColor: textColor
            });
            xLabel.position.set(0, -40, -gridSize - 15);
            scene.add(xLabel);
            meshes.push(xLabel);
            
            // Y Label
            const yLabel = createTextSprite(getGreekDisplayName(greekSelect.value), {
                fontsize: 24,
                textColor: textColor
            });
            yLabel.position.set(-gridSize - 25, 50, -gridSize - 15);
            scene.add(yLabel);
            meshes.push(yLabel);
            
            // Z Label
            const zLabel = createTextSprite("Implied Volatility (IV)", {
                fontsize: 24,
                textColor: textColor
            });
            zLabel.position.set(-gridSize - 25, -40, 0);
            scene.add(zLabel);
            meshes.push(zLabel);
        }

        // Initialize on load
        window.addEventListener('load', function() {
            // First check if WebGL is supported
            if (!checkWebGLSupport()) {
                showFallbackUI('WebGL is not supported by your browser. Switching to 2D mode.');
                return;
            }
            
            // Set a timeout to detect if initialization takes too long
            initializationTimeout = setTimeout(function() {
                if (!initializationAttempted) {
                    loadingElement.innerHTML = `
                        <div>Still loading...</div>
                        <div class="loading-spinner"></div>
                        <div class="loading-tips">
                            This is taking longer than expected. You can:
                            <br>- Continue waiting
                            <br>- Try refreshing the page
                            <br>- Switch to 2D mode
                        </div>
                        <button id="switch2DButton" class="fallback-button">Switch to 2D Mode</button>
                    `;
                    
                    document.getElementById('switch2DButton').addEventListener('click', function() {
                        clearTimeout(initializationTimeout);
                        use2DMode = true;
                        init2DMode();
                        loadingElement.style.display = 'none';
                    });
                }
            }, 10000); // 10 seconds timeout
            
            // Try to initialize
            try {
                init();
            } catch (e) {
                clearTimeout(initializationTimeout);
                showFallbackUI('Failed to initialize 3D visualization. Switching to 2D mode.');
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (use2DMode) {
                init2DMode(); // Redraw 2D chart
            } else if (camera && renderer) {
                camera.aspect = plotContainer.clientWidth / plotContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
            }
        });

        // Event listeners for controls
        greekSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        optionTypeSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        positionTypeSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        daysToExpiryInput.addEventListener('change', () => {
            // Validate input: ensure it's between 0.01 and 365
            let days = parseFloat(daysToExpiryInput.value);
            if (isNaN(days) || days < 0.000001) days = 0.000001;
            if (days > 365) days = 365;
            daysToExpiryInput.value = days; // Update with validated value
            
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
    </script>
</body>
</html>
