<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black-Scholes Greeks 3D Visualization</title>
    
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <!-- OrbitControls for camera manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        /* SPX/VIX Banner Styles */
        /* Add this to your existing banner styles */
.banner-title {
    flex: 1;
    text-align: left;
}

.banner-title h2 {
    margin: 0;
    font-size: 18px;
    font-weight: 700;
    color: #ffffff;
    letter-spacing: 1px;
    text-transform: uppercase;
}

/* Update banner-content to better accommodate the title */
.banner-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px; /* Increased gap for better spacing */
}

/* Responsive adjustments for mobile */
@media (max-width: 768px) {
    .banner-title h2 {
        font-size: 16px;
        text-align: center;
    }
    
    .banner-content {
        flex-direction: column;
        gap: 15px;
    }
    
    .banner-title {
        text-align: center;
        width: 100%;
    }
}
.spx-vix-banner {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: linear-gradient(135deg, #1a2235 0%, #2a3c54 100%);
    border-bottom: 2px solid #4f8fff;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

.banner-content {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
}

.banner-section {
    display: flex;
    align-items: center;
    gap: 20px;
}

.metric-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 100px;
}

.metric-label {
    font-size: 12px;
    color: #aabbcc;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 2px;
}

.metric-value {
    font-size: 16px;
    font-weight: 700;
    color: #ffffff;
}

.driver-display {
    max-width: 300px;
    font-size: 13px;
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.1);
    padding: 8px 12px;
    border-radius: 6px;
    text-align: center;
    border-left: 3px solid #4f8fff;
}

.refresh-button {
    background: linear-gradient(135deg, #4f8fff 0%, #7fafff 100%);
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: all 0.3s ease;
}

.refresh-button:hover {
    background: linear-gradient(135deg, #7fafff 0%, #4f8fff 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(79, 143, 255, 0.3);
}

.loading-spinner-banner {
    width: 16px;
    height: 16px;
    border: 2px solid #aabbcc;
    border-top: 2px solid #4f8fff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}

.status-indicator {
    display: flex;
    align-items: center;
    font-size: 12px;
    color: #aabbcc;
}

/* Adjust body for banner */
body {
    padding-top: 70px; /* Add space for fixed banner */
}
       /* Complete MathJax scroll removal */

/* Hide MathJax scroll arrows and controls */
.mjx-container .mjx-mrow > .mjx-mo[data-semantic-type="relation"]:first-child,
.mjx-container .mjx-mrow > .mjx-mo[data-semantic-type="relation"]:last-child {
    display: none !important;
}

/* Hide all scrollbars on MathJax elements */
.mjx-container::-webkit-scrollbar {
    display: none !important;
    width: 0 !important;
    height: 0 !important;
}

.mjx-container {
    scrollbar-width: none !important; /* Firefox */
    -ms-overflow-style: none !important; /* IE/Edge */
    overflow: visible !important; /* Force visible overflow */
}

/* Hide any MathJax scroll controls and menus */
.mjx-assistive-mml,
.mjx-scroll,
.MathJax_MenuArrow,
.mjx-menu,
.mjx-overflow,
.mjx-tool-item {
    display: none !important;
}

/* Prevent MathJax from creating scrollable containers */
.mjx-container,
.mjx-display,
.mjx-math {
    overflow: visible !important;
    max-width: none !important;
}

/* Hide MathJax context menu and accessibility features that might show scrolls */
.mjx-a11y,
.mjx-menu-item,
.mjx-menu-rule {
    display: none !important;
}
        /* Overall layout */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            background-color: #111624;
            color: #ffffff;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Controls panel */
        .controls-panel {
            width: 300px;
            background-color: #1a2235;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #ffffff;
        }

        .control-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #2a3c54;
            border-radius: 4px;
            font-size: 14px;
            background-color: #1e293e;
            color: #ffffff;
        }

        .info-panel {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2a3c54;
        }

        .info-panel h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .info-panel ul {
            padding-left: 20px;
            font-size: 13px;
            color: #aabbcc;
        }

        /* 3D visualization container */
        .visualization-container {
            flex: 1;
            position: relative;
            height: 600px;
            background-color: #111624;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        #plotContainer {
            width: 100%;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(17, 22, 36, 0.9);
            z-index: 10;
            font-weight: 600;
            gap: 15px;
            color: #ffffff;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 5px solid #1e293e;
            border-top: 5px solid #4f8fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-tips {
            font-size: 14px;
            color: #aabbcc;
            margin-top: 10px;
        }

        #fallback-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            background-color: #111624;
            color: #ffffff;
            z-index: 5;
            overflow: auto;
            display: none;
        }

        .fallback-button {
            margin-top: 15px;
            padding: 8px 16px;
            background-color: #3d8a3d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .fallback-button:hover {
            background-color: #2d682d;
        }

        /* Value display panel */
        .value-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(20, 27, 44, 0.85);
            border: 1px solid #2a3c54;
            border-radius: 4px;
            padding: 10px;
            font-size: 14px;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .value-display p {
            margin: 5px 0;
        }

        /* Guide panel */
        .guide-panel {
            background-color: #1a2235;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            color: #ffffff;
        }

        .guide-panel h3 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #ffffff;
        }

        .guide-panel p {
            font-size: 14px;
            color: #aabbcc;
        }

        /* Formula section styling */
        .formula-section {
            margin-top: 20px;
        }

        .formulas {
        display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); /* Increased from 300px */
            gap: 20px;
            margin-top: 15px;
        }

        .formula {
            background-color: #1e293e;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .formula h4 {
            border-bottom: 1px solid #2a3c54;
            padding-bottom: 8px;
            margin-bottom: 10px;
            color: #ffffff;
            font-size: 16px;
        }

        .formula p {
            margin: 8px 0;
            color: #aabbcc;
            font-size: 14px;
            line-height: 1.6;
            overflow-wrap: break-word; /* Break long formulas */
            word-break: break-word; /* Additional word breaking */
        }

        .formula-notes {
            grid-column: 1 / -1;
            background-color: #1e293e;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .formula-notes ul {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            list-style-type: none;
            padding-left: 0;
            margin-top: 10px;
        }

        .formula-notes li {
            color: #aabbcc;
            font-size: 14px;
            padding-left: 15px;
            position: relative;
        }

        .formula-notes li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #4f8fff;
        }

        /* MathJax styling for dark theme */
        .MathJax {
            color: #ffffff !important;
        }

        .formula .MathJax {
            font-size: 120% !important;
        }

        .formula .MJX-TEX .mjx-frac {
            font-size: 130% !important;
            vertical-align: -0.5em;
        }

        .formula .MJX-TEX .mjx-num {
            padding-bottom: 0.2em;
        }

        .formula .MJX-TEX .mjx-den {
            padding-top: 0.2em;
            border-top-width: 2px;
        }

        /* LinkedIn link styling */
        .linkedin-link {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            transition: transform 0.2s;
        }

        .linkedin-link:hover {
            transform: scale(1.1);
        }

        /* Footer styling */
        .footer {
            margin-top: 20px;
            padding: 15px 0;
            text-align: center;
            border-top: 1px solid #2a3c54;
        }

        .footer p {
            font-size: 14px;
            color: #aabbcc;
        }

        .footer a {
            color: #4f8fff;
            text-decoration: none;
            transition: color 0.2s;
        }

        .footer a:hover {
            color: #7fafff;
            text-decoration: underline;
        }

        /* Responsive adjustments */
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            
            .controls-panel {
                width: 100%;
            }

            .linkedin-link {
                top: 10px;
                right: 10px;
            }
        }
                /* Make MathJax formulas responsive */
        .formula .MathJax {
            font-size: 110% !important; /* Reduced from 120% */
            max-width: 100% !important;
            overflow-x: auto !important; /* Add horizontal scroll if needed */
            overflow-y: hidden !important;
        }

        /* Specific fixes for complex formulas */
        .formula .MJX-TEX {
            max-width: 100% !important;
            overflow-x: auto !important;
            font-size: 0.9em !important; /* Slightly smaller for complex formulas */
        }

        /* Special handling for wide formulas */
        .formula.wide-formula {
            grid-column: span 2; /* Span two columns if needed */
            min-width: 500px;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .formulas {
                grid-template-columns: 1fr; /* Single column on mobile */
            }
            
            .formula .MathJax {
                font-size: 100% !important; /* Even smaller on mobile */
            }
            
            .formula.wide-formula {
                grid-column: span 1; /* Single column on mobile */
                min-width: auto;
            }
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <!-- SPX/VIX Banner -->
<div class="spx-vix-banner">
    <div class="banner-content">
        <div class="banner-title">
            <h2>Daily SPOT VOL Relationship</h2>
        </div>
        <div class="banner-section">
            <div class="metric-item">
                <div class="metric-label">SPX Change</div>
                <div class="metric-value" id="spx-change">-</div>
            </div>
            <div class="metric-item">
                <div class="metric-label">VIX Change</div>
                <div class="metric-value" id="vix-change">-</div>
            </div>
            <div class="metric-item">
                <div class="metric-label">Residual</div>
                <div class="metric-value" id="residual-value">-</div>
            </div>
        </div>
        
        <div class="driver-display" id="driver-display">
            Loading market data...
        </div>
        
        <div class="banner-section">
            <div class="status-indicator" id="status-indicator">
                <div class="loading-spinner-banner"></div>
                Updating...
            </div>
            <button class="refresh-button" onclick="updateBannerData()">Refresh</button>
        </div>
    </div>
</div>
    <div class="container">
        <h1>Black-Scholes Greeks 3D Visualization</h1>
        
        <div class="main-content">
            <!-- Controls -->
            <div class="controls-panel">
                <div class="control-group">
                    <label for="greekSelect">Greek</label>
                    <select id="greekSelect" class="control-input">
                        <option value="delta">Delta (Δ)</option>
                        <option value="vega">Vega (ν)</option>
                        <option value="theta">Theta (Θ)</option>
                        <option value="gamma">Gamma (Γ)</option>
                        <option value="vanna">Vanna</option>
                        <option value="charm">Charm</option>
                        <option value="vomma">Vomma</option>
                        <option value="veta">Veta</option>
                        <option value="speed">Speed</option>
                        <option value="zomma">Zomma</option>
                        <option value="color">Color</option>
                        <option value="ultima">Ultima</option>
                        <option value="parmicharma">Parmicharma</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="optionTypeSelect">Option Type</label>
                    <select id="optionTypeSelect" class="control-input">
                        <option value="call">Call</option>
                        <option value="put">Put</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="positionTypeSelect">Position</label>
                    <select id="positionTypeSelect" class="control-input">
                        <option value="long">Long</option>
                        <option value="short">Short</option>
                    </select>
                    <div class="control-group">
                        <label for="daysToExpiryInput">Days to Expiry</label>
                        <input type="number" id="daysToExpiryInput" class="control-input" value="1" min="0.000001" max="10000" step="1">
                    </div>
                </div>
                
                <div class="info-panel">
                    <h3>Parameters</h3>
                    <ul>
                        <li>standard normal distribution</li>
                        <li>Spot (S): 6000</li>
                        <li>Strike (K): 5600-6400 </li>
                        <li>Interest Rate (r): 0.03</li>
                        <li>Dividend Yield (q): 0.00001</li>
                        <li>Time to Expiry (τ): Input/365 </li>
                        <li>IV: 0.10-0.90 in steps of 0.01</li>
                        <li>Vanna is devided by 100</li>
                        <li>Theta and charm are multiplied by 1/251</li>
                    </ul>
                </div>
                
                <div class="info-panel">
                    <h3>Navigation</h3>
                    <ul>
                        <li>Click and drag to rotate</li>
                        <li>Scroll to zoom in/out</li>
                        <li>Right-click and drag to pan</li>
                    </ul>
                </div>
            </div>
            
            <!-- 3D Plot -->
            <div class="visualization-container">
                <div id="loading">
                    <div class="loading-spinner"></div>
                    <div>Initializing 3D visualization...</div>
                    <div class="loading-tips">This may take a few moments for the first load</div>
                </div>
                <div id="plotContainer"></div>
                <div id="value-display" class="value-display">
                    <h3>Position Information</h3>
                    <p><strong>Strike:</strong> <span id="strike-value">-</span></p>
                    <p><strong>IV:</strong> <span id="iv-value">-</span></p>
                    <p><strong>Greek Value:</strong> <span id="greek-value">-</span></p>
                </div>
                <div id="fallback-container">
                    <h3>3D Visualization Not Available</h3>
                    <p>The 3D visualization couldn't be loaded. This might be due to:</p>
                    <ul>
                        <li>WebGL not being supported by your browser</li>
                        <li>Insufficient system resources</li>
                        <li>Browser extensions blocking JavaScript</li>
                    </ul>
                    <p>Try the following:</p>
                    <ul>
                        <li>Use a modern browser like Chrome, Firefox, or Edge</li>
                        <li>Disable hardware acceleration in your browser settings</li>
                        <li>Close other tabs and applications to free up memory</li>
                        <li>Try the 2D visualization option</li>
                    </ul>
                    <button id="show2DButton" class="fallback-button">Switch to 2D View</button>
                </div>
            </div>
        </div>
        
        <div class="guide-panel">
            <h3>Visualization Guide</h3>
            <p>
                This 3D plot shows how the selected option Greek varies with both Strike Price (K) and 
                Implied Volatility (IV). The x-axis represents Strike Price, the y-axis shows the Greek value, 
                and the z-axis represents Implied Volatility. The lines along the curves highlight each strike
                price across different IV levels. Hover over the surface to see exact values.
            </p>
            <!-- Replace the existing formula section in your HTML with this updated version -->

<div class="guide-panel formula-section">
    <h3>Option Greeks Formulas</h3>
    <div class="formulas">
      <!-- First Order Greeks -->
      <div class="formula">
        <h4>Delta (Δ)</h4>
        <p>Call: \(e^{-qT} N(d_1)\)</p>
        <p>Put: \(-e^{-qT} N(-d_1)\)</p>
      </div>
      
      <div class="formula">
        <h4>Gamma (Γ)</h4>
        <p>\(\frac{e^{-qT} N'(d_1)}{S\sigma\sqrt{T}}\)</p>
      </div>
      
      <div class="formula">
        <h4>Vega (ν)</h4>
        <p>\(S e^{-qT} N'(d_1) \sqrt{T}\)</p>
      </div>
      
      <div class="formula">
        <h4>Theta (Θ)</h4>
        <p>Call: \(-\frac{S e^{-qT} N'(d_1) \sigma}{2\sqrt{T}} - rKe^{-rT}N(d_2) + qSe^{-qT}N(d_1)\)</p>
        <p>Put: \(-\frac{S e^{-qT} N'(d_1) \sigma}{2\sqrt{T}} + rKe^{-rT}N(-d_2) - qSe^{-qT}N(-d_1)\)</p>
      </div>

      <!-- Second Order Greeks -->
      <div class="formula">
        <h4>Vanna</h4>
        <p>\(-e^{-qT} N'(d_1) \frac{d_2}{\sigma}\)</p>
      </div>
      
      <div class="formula">
        <h4>Charm</h4>
        <p>Call: \(qe^{-qT}N(d_1) - e^{-qT}N'(d_1) \times \frac{2(r-q)T - d_2\sigma\sqrt{T}}{2T\sigma\sqrt{T}}\)</p>
        <p>Put: \(-qe^{-qT}N(-d_1) - e^{-qT}N'(d_1) \times \frac{2(r-q)T - d_2\sigma\sqrt{T}}{2T\sigma\sqrt{T}}\)</p>
      </div>

      <div class="formula">
        <h4>Vomma (Volga)</h4>
        <p>\(\nu \frac{d_1 d_2}{\sigma}\)</p>
      </div>

      <div class="formula">
        <h4>Veta</h4>
        <p>\(-Se^{-qT}N'(d_1)\sqrt{T} \times \left[q + \frac{(r-q)d_1}{\sigma\sqrt{T}} - \frac{1+d_1d_2}{2T}\right]\)</p>
      </div>

      <!-- Third Order Greeks -->
      <div class="formula">
        <h4>Speed</h4>
        <p>\(-e^{-qT}\frac{N'(d_1)}{S^2\sigma\sqrt{T}} \times \left(\frac{d_1}{\sigma\sqrt{T}} + 1\right)\)</p>
      </div>

      <div class="formula">
        <h4>Zomma</h4>
        <p>\(e^{-qT}\frac{N'(d_1)(d_1d_2-1)}{S\sigma^2\sqrt{T}}\)</p>
      </div>

      <div class="formula">
        <h4>Color</h4>
        <p>\(-e^{-qT}\frac{N'(d_1)}{2ST\sigma\sqrt{T}} \times \left[2qT + 1 + \frac{2(r-q)T - d_2\sigma\sqrt{T}}{\sigma\sqrt{T}}d_1\right]\)</p>
      </div>

      <div class="formula">
        <h4>Ultima</h4>
        <p>\(-\frac{\nu}{\sigma^2}[d_1d_2(1-d_1d_2) + d_1^2 + d_2^2]\)</p>
      </div>

      <!-- Parmicharma - Fixed to be in single formula box -->
      <div class="formula">
        <h4>Parmicharma</h4>
        <p>\(\left(q - \frac{2(r-q)T - d_2\sigma\sqrt{T}}{2T\sigma\sqrt{T}}\right) \times \text{charm} - e^{-qT}N'(d_1) \times \frac{2d_2\sigma^2T - (r-q)\sigma T\sqrt{T} - \sigma^3T^2\frac{\partial d_2}{\partial T}}{2T^3\sigma^2}\)</p>
        <p>Where: \(\frac{\partial d_2}{\partial T} = \frac{(r-q+\sigma^2/2)}{\sigma\sqrt{T}} - \frac{d_1}{2T} - \frac{\sigma}{2\sqrt{T}}\)</p>
      </div>

      <!-- Reference section -->
      <div class="formula-notes">
        <p><strong>Where:</strong></p>
        <div class="formula-variables">
          <p>\(d_1 = \frac{\ln(S/K) + (r - q + \sigma^2/2)T}{\sigma\sqrt{T}}\)</p>
          <p>\(d_2 = d_1 - \sigma\sqrt{T}\)</p>
          <p>\(N(x)\) is the standard normal CDF</p>
          <p>\(N'(x)\) is the standard normal PDF</p>
          <p>\(S\) is the spot price, \(K\) is the strike price</p>
          <p>\(r\) is the risk-free rate, \(q\) is the dividend yield</p>
          <p>\(\sigma\) is the volatility, \(T\) is the time to expiry</p>
          <p>\(\nu\) is vega</p>
        </div>
      </div>

      <!-- Classification section -->
      <div class="formula-notes">
        <p><strong>Greek Classifications:</strong></p>
        <div class="greek-classifications">
          <p><strong>First Order:</strong> Delta, Vega, Theta</p>
          <p><strong>Second Order:</strong> Gamma, Vanna, Charm, Vomma, Veta</p>
          <p><strong>Third Order:</strong> Speed, Zomma, Color, Ultima, Parmicharma</p>
        </div>
      </div>
    </div>
</div>
              <div class="footer">
                <p>Created by <a href="https://www.linkedin.com/in/johannes-dassler-19473b225/" target="_blank" rel="noopener noreferrer">Johannes Dassler</a></p>
              </div>
        </div>
        <a href="https://www.linkedin.com/in/johannes-dassler-19473b225/" target="_blank" rel="noopener noreferrer" class="linkedin-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#4f8fff">
                <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z"/>
            </svg>
        </a>
    </div>
    
    <script>
        // JavaScript version of your Python function
// 1. Fetch Funktion für Yahoo Finance
async function fetchYahooFinanceData(symbol) {
    try {
        // CORS Proxy verwenden
        const proxyUrl = 'https://api.allorigins.win/get?url=';
        const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`;
        const fullUrl = proxyUrl + encodeURIComponent(yahooUrl);
        
        console.log(`Fetching ${symbol} via proxy...`);
        
        const response = await fetch(fullUrl);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const proxyData = await response.json();
        const data = JSON.parse(proxyData.contents);
        
        const result = data.chart.result[0];
        const meta = result.meta;
        
        console.log(`${symbol} data:`, meta);
        
        return {
            regularMarketPrice: meta.regularMarketPrice,
            regularMarketOpen: meta.regularMarketOpen || meta.previousClose,
            symbol: symbol
        };
    } catch (error) {
        console.error(`Error fetching ${symbol}:`, error);
        
        // Fallback zu alternativer API wenn Proxy fehlschlägt
        try {
            return await fetchAlternativeData(symbol);
        } catch (fallbackError) {
            console.error(`Fallback also failed for ${symbol}:`, fallbackError);
            return null;
        }
    }
}

// Alternative Fallback-Funktion
async function fetchAlternativeData(symbol) {
    // Finnhub als Backup (kostenlos)
    const finnhubToken = 'sandbox_c9k8qeaad3ieqa8bccrg';
    let finnhubSymbol = symbol;
    
    // Symbol mapping für Finnhub
    if (symbol === '^GSPC') finnhubSymbol = 'SPX';
    if (symbol === '^VIX') finnhubSymbol = 'VIX';
    
    const url = `https://finnhub.io/api/v1/quote?symbol=${finnhubSymbol}&token=${finnhubToken}`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.c && data.o) {
        return {
            regularMarketPrice: data.c, // current price
            regularMarketOpen: data.o,  // open price
            symbol: symbol
        };
    } else {
        throw new Error('No data from alternative API');
    }
}

// 2. Deine Residual Berechnung (die du schon hast)
async function calculateResidualWithDrivers() {
    try {
        console.log('Fetching SPX and VIX data...');
        
        const [spxData, vixData] = await Promise.all([
            fetchYahooFinanceData('^GSPC'),
            fetchYahooFinanceData('^VIX')
        ]);
        
        if (!spxData || !vixData) {
            throw new Error('Failed to fetch market data');
        }
        
        console.log('SPX:', spxData);
        console.log('VIX:', vixData);
        
        const spxChange = spxData.regularMarketPrice / spxData.regularMarketOpen - 1;
        const vixChange = vixData.regularMarketPrice / vixData.regularMarketOpen - 1;
        const predictedVixChange = 0.008343 + spxChange * -6.411903;
        const residual = vixChange - predictedVixChange;
        
        let driver;
        if (Math.abs(spxChange) < 0.001) {
            driver = `VIX_INDEPENDENT (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
        } else if (Math.abs(vixChange) < 0.005) {
            driver = `VIX_UNRESPONSIVE (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
        } else if ((spxChange > 0 && vixChange > 0) || (spxChange < 0 && vixChange < 0)) {
            driver = `WRONG_DIRECTION (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
        } else if (Math.abs(residual) > 0.02) {
            if (Math.abs(vixChange) > Math.abs(predictedVixChange) * 1.5) {
                driver = `VIX_OVERREACTION (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
            } else {
                driver = `VIX_UNDERREACTION (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
            }
        } else {
            driver = `NORMAL (SPX: ${spxChange.toFixed(4)}, VIX: ${vixChange.toFixed(4)})`;
        }
        
        return {
            spx_change: spxChange,
            vix_change: vixChange,
            predicted_vix_change: predictedVixChange,
            residual: residual,
            driver: driver,
            spx_price: spxData.regularMarketPrice,
            vix_price: vixData.regularMarketPrice
        };
    } catch (error) {
        console.error('Error calculating residual:', error);
        return null;
    }
}

// 3. Die fehlende updateBannerData Funktion
async function updateBannerData() {
    const statusIndicator = document.getElementById('status-indicator');
    const spxChangeEl = document.getElementById('spx-change');
    const vixChangeEl = document.getElementById('vix-change');
    const residualEl = document.getElementById('residual-value');
    const driverEl = document.getElementById('driver-display');
    
    // Show loading state
    statusIndicator.innerHTML = '<div class="loading-spinner-banner"></div>Updating...';
    
    const result = await calculateResidualWithDrivers();
    
    if (result) {
        // Update values
        spxChangeEl.textContent = `${(result.spx_change * 100).toFixed(2)}%`;
        vixChangeEl.textContent = `${(result.vix_change * 100).toFixed(2)}%`;
        residualEl.textContent = result.residual.toFixed(4);
        driverEl.textContent = result.driver;
        
        // Color coding for residual
        if (Math.abs(result.residual) > 0.02) {
            residualEl.style.color = '#ff6b6b';
        } else if (Math.abs(result.residual) > 0.01) {
            residualEl.style.color = '#ffd93d';
        } else {
            residualEl.style.color = '#6bcf7f';
        }
        
        statusIndicator.innerHTML = `Last updated: ${new Date().toLocaleTimeString()}`;
    } else {
        statusIndicator.innerHTML = 'Update failed';
        driverEl.textContent = 'Error loading data';
    }
}

// 4. Auto-initialize
document.addEventListener('DOMContentLoaded', function() {
    updateBannerData();
    
    // Auto-refresh every 30 seconds
    setInterval(updateBannerData, 30000);
});

        // Constants for the Black-Scholes model
        const DEFAULT_SPOT = 6000;
        const DEFAULT_RATE = 0.03;
        const DEFAULT_DIVIDEND = 0.00001;
        
        // DOM elements
        const daysToExpiryInput = document.getElementById('daysToExpiryInput');
        const greekSelect = document.getElementById('greekSelect');
        const optionTypeSelect = document.getElementById('optionTypeSelect');
        const positionTypeSelect = document.getElementById('positionTypeSelect');
        const plotContainer = document.getElementById('plotContainer');
        const loadingElement = document.getElementById('loading');
        const fallbackContainer = document.getElementById('fallback-container');
        const show2DButton = document.getElementById('show2DButton');
        const valueDisplay = document.getElementById('value-display');
        const strikeValueElement = document.getElementById('strike-value');
        const ivValueElement = document.getElementById('iv-value');
        const greekValueElement = document.getElementById('greek-value');

        // Three.js variables
        let scene, camera, renderer, controls, raycaster, mouse;
        let meshes = [];
        let surfaceMesh;
        let gridGroup;
        let strikeLines = [];
        let strikeData = {};
        let minValueGlobal = 0;
        let maxValueGlobal = 0;

        // Fallback mode flag
        let use2DMode = false;
        let initializationAttempted = false;
        let initializationTimeout;

        // Check WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                return !!(
                    window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
                );
            } catch (e) {
                return false;
            }
        }

        // Show fallback UI if WebGL or Three.js fails
        function showFallbackUI(message) {
            console.error(message);
            loadingElement.style.display = 'none';
            fallbackContainer.style.display = 'block';
            
            show2DButton.addEventListener('click', function() {
                use2DMode = true;
                fallbackContainer.style.display = 'none';
                init2DMode();
            });
        }

        // Initialize 2D mode (simplified visualization)
        function init2DMode() {
            plotContainer.innerHTML = '';
            plotContainer.style.display = 'flex';
            plotContainer.style.flexDirection = 'column';
            plotContainer.style.alignItems = 'center';
            plotContainer.style.justifyContent = 'center';
            plotContainer.style.padding = '20px';
            valueDisplay.style.display = 'none';
            
            const title = document.createElement('h3');
            title.textContent = `${getGreekDisplayName(greekSelect.value)} for ${positionTypeSelect.value} ${optionTypeSelect.value} options`;
            title.style.color = '#ffffff';
            plotContainer.appendChild(title);
            
            // Create line chart using canvas
            const canvas = document.createElement('canvas');
            canvas.width = plotContainer.clientWidth - 40;
            canvas.height = 400;
            plotContainer.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            draw2DChart(ctx, canvas.width, canvas.height);
            
            // Add legend
            const legend = document.createElement('div');
            legend.style.display = 'flex';
            legend.style.flexWrap = 'wrap';
            legend.style.marginTop = '20px';
            legend.style.justifyContent = 'center';
            legend.style.color = '#ffffff';
            
            [5800, 5900, 6000, 6100, 6200].forEach(strike => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.margin = '0 10px 10px 0';
                
                const color = document.createElement('div');
                color.style.width = '20px';
                color.style.height = '3px';
                color.style.backgroundColor = getColorForStrike(strike);
                color.style.marginRight = '5px';
                
                const label = document.createElement('span');
                label.textContent = `Strike ${strike}`;
                
                item.appendChild(color);
                item.appendChild(label);
                legend.appendChild(item);
            });
            
            plotContainer.appendChild(legend);
            
            // Add event listener for controls
            greekSelect.addEventListener('change', () => init2DMode());
            optionTypeSelect.addEventListener('change', () => init2DMode());
            positionTypeSelect.addEventListener('change', () => init2DMode());
        }

        // Draw 2D chart on canvas (simplified visualization)
        function draw2DChart(ctx, width, height) {
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            
            // Fill dark background
            ctx.fillStyle = '#111624';
            ctx.fillRect(0, 0, width, height);
            
            // Generate data (simplified for 2D)
            const strikes = [];
            for (let strike = 5800; strike <= 6200; strike += 25) {
                strikes.push(strike);
            }
            
            const ivValues = [];
            for (let iv = 0.1; iv <= 0.9; iv += 0.05) {
                ivValues.push(iv);
            }
            
            // Find min/max values for scaling
            let minValue = Infinity;
            let maxValue = -Infinity;
            
            strikes.forEach(strike => {
                ivValues.forEach(iv => {
                    const value = getGreekValue(DEFAULT_SPOT, strike, iv);
                    minValueGlobal = minValue;
                    maxValueGlobal = maxValue;
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                });
            });
            
            // Add some padding to min/max
            const valuePadding = (maxValue - minValue) * 0.1;
            minValue -= valuePadding;
            maxValue += valuePadding;
            
            // Draw grid
            ctx.strokeStyle = '#2a3c54';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = height - padding - (i / 5) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let i = 0; i <= ivValues.length; i += 2) {
                const x = padding + (i / ivValues.length) * chartWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#4f8fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            // X-axis (IV)
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            
            // Y-axis (Greek value)
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(padding, padding);
            
            ctx.stroke();
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            
            ivValues.forEach((iv, index) => {
                if (index % 2 === 0) { // Show every other label to avoid crowding
                    const x = padding + (index / (ivValues.length - 1)) * chartWidth;
                    ctx.fillText(iv.toFixed(2), x, height - padding + 5);
                }
            });
            
            // Draw Y-axis labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i <= 5; i++) {
                const value = minValue + (i / 5) * (maxValue - minValue);
                const y = height - padding - (i / 5) * chartHeight;
                ctx.fillText(value.toFixed(4), padding - 5, y);
            }
            
            // Draw axis titles
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Implied Volatility (IV)', width / 2, height - 5);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textBaseline = 'top';
            ctx.fillText(getGreekDisplayName(greekSelect.value), 0, 0);
            ctx.restore();
            
            // Draw lines for each strike price
            strikes.forEach(strike => {
                const points = [];
                
                ivValues.forEach(iv => {
                    const value = getGreekValue(DEFAULT_SPOT, strike, iv);
                    const x = padding + ((iv - 0.1) / 0.8) * chartWidth;
                    const y = height - padding - ((value - minValue) / (maxValue - minValue)) * chartHeight;
                    points.push({x, y});
                });
                
                // Draw line with green coloring similar to reference
                const strikePct = (strike - 5800) / 400; // Normalized 0-1
                const green = 128 + Math.round(strikePct * 127);
                ctx.strokeStyle = `rgb(51, ${green}, 102)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.stroke();
            });
        }

        // Error function implementation (for standard normal CDF)
        function erf(x) {
            // Constants
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            // Save the sign
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            
            // Approximation formula
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return sign * y;
        }

        // Standard normal CDF (Cumulative Distribution Function)
        function normCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        // Standard normal PDF (Probability Density Function)
        function normPDF(x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }

        // Calculate d1 and d2 for Black-Scholes
        function calculateDs(S, K, r, q, sigma, T) {
            const d1 = (Math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
            const d2 = d1 - sigma * Math.sqrt(T);
            return { d1, d2 };
        }

        // Calculate Call option price and Greeks
        function calculateCallOption(S, K, r, q, sigma, T) {
            const { d1, d2 } = calculateDs(S, K, r, q, sigma, T);
            
            // Using the formulas provided in the original request
            const price = S * Math.exp(-q * T) * normCDF(d1) - K * Math.exp(-r * T) * normCDF(d2);
            const delta = Math.exp(-q * T) * normCDF(d1);
            const gamma = Math.exp(-q * T) * normPDF(d1) / (S * sigma * Math.sqrt(T));
            const vega = S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T);
            const vanna = (Math.exp(-q * T) * normPDF(d1) * (d2 / sigma))/(-100);
            const charm = (-q * Math.exp(-q * T) * normCDF(d1) - Math.exp(-q * T) * normPDF(d1) * 
            (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T)))/(251);
            const theta = -(((S * Math.exp(-q * T) * normPDF(d1) * sigma) / (2 * Math.sqrt(T))) - 
              (r * K * Math.exp(-r * T) * normCDF(d2)) + 
              (q * S * Math.exp(-q * T) * normCDF(d1)))/251;
            const vomma = vega * (d1 * d2) / sigma;
            const veta = -S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T) * 
                (q + ((r - q) * d1) / (sigma * Math.sqrt(T)) - (1 + d1 * d2) / (2 * T));
            const speed = -Math.exp(-q * T) * normPDF(d1) / (S * S * sigma * Math.sqrt(T)) * 
                (d1 / (sigma * Math.sqrt(T)) + 1);
            const zomma = Math.exp(-q * T) * normPDF(d1) * (d1 * d2 - 1) / (S * sigma * sigma * Math.sqrt(T));
            const color = -Math.exp(-q * T) * normPDF(d1) / (2 * S * T * sigma * Math.sqrt(T)) * 
                (2 * q * T + 1 + (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (sigma * Math.sqrt(T)) * d1);
            const ultima = -vega / (sigma * sigma) * (d1 * d2 * (1 - d1 * d2) + d1 * d1 + d2 * d2);
            const dd1_dt = (r - q + sigma * sigma / 2) / (sigma * Math.sqrt(T)) - d1 / (2 * T);
            const dd2_dt = dd1_dt - sigma / (2 * Math.sqrt(T));
            const parmicharma = ((q - (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T))) * charm - 
                Math.exp(-q * T) * normPDF(d1) * (2 * d2 * sigma * sigma * T - (r - q) * sigma * T * Math.sqrt(T) - 
                sigma * sigma * sigma * T * T * dd2_dt) / (2 * T * T * T * sigma * sigma))/2008;

            return { price, delta, gamma, vega, vanna, charm, theta, vomma, veta, speed, zomma, color, ultima, parmicharma };
        }

        // Calculate Put option price and Greeks
        function calculatePutOption(S, K, r, q, sigma, T) {
            const { d1, d2 } = calculateDs(S, K, r, q, sigma, T);
            
            const price = K * Math.exp(-r * T) * normCDF(-d2) - S * Math.exp(-q * T) * normCDF(-d1);
            const delta = -Math.exp(-q * T) * normCDF(-d1);
            const gamma = Math.exp(-q * T) * normPDF(d1) / (S * sigma * Math.sqrt(T));
            const vega = S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T);
            const vanna = (Math.exp(-q * T) * normPDF(d1) * (d2 / sigma))/(-100);
            const charm = (q * Math.exp(-q * T) * normCDF(-d1) - Math.exp(-q * T) * normPDF(d1) * 
            (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T)))/(251);
            const theta = -(((S * Math.exp(-q * T) * normPDF(d1) * sigma) / (2 * Math.sqrt(T))) + 
              (r * K * Math.exp(-r * T) * normCDF(-d2)) - 
              (q * S * Math.exp(-q * T) * normCDF(-d1)))/251;
            const vomma = vega * (d1 * d2) / sigma;
            const veta = -S * Math.exp(-q * T) * normPDF(d1) * Math.sqrt(T) * 
                (q + ((r - q) * d1) / (sigma * Math.sqrt(T)) - (1 + d1 * d2) / (2 * T));
            const speed = -Math.exp(-q * T) * normPDF(d1) / (S * S * sigma * Math.sqrt(T)) * 
                (d1 / (sigma * Math.sqrt(T)) + 1);
            const zomma = Math.exp(-q * T) * normPDF(d1) * (d1 * d2 - 1) / (S * sigma * sigma * Math.sqrt(T));
            const color = -Math.exp(-q * T) * normPDF(d1) / (2 * S * T * sigma * Math.sqrt(T)) * 
                (2 * q * T + 1 + (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (sigma * Math.sqrt(T)) * d1);
            const ultima = -vega / (sigma * sigma) * (d1 * d2 * (1 - d1 * d2) + d1 * d1 + d2 * d2);
            const dd1_dt = (r - q + sigma * sigma / 2) / (sigma * Math.sqrt(T)) - d1 / (2 * T);
            const dd2_dt = dd1_dt - sigma / (2 * Math.sqrt(T));
            const parmicharma = ((q - (2 * (r - q) * T - d2 * sigma * Math.sqrt(T)) / (2 * T * sigma * Math.sqrt(T))) * charm - 
                Math.exp(-q * T) * normPDF(d1) * (2 * d2 * sigma * sigma * T - (r - q) * sigma * T * Math.sqrt(T) - 
                sigma * sigma * sigma * T * T * dd2_dt) / (2 * T * T * T * sigma * sigma))/2008;

            return { price, delta, gamma, vega, vanna, charm, theta, vomma, veta, speed, zomma, color, ultima, parmicharma };
        }

        // Helper function to get the selected Greek value based on option type and position
        function getGreekValue(S, K, iv) {
            const greek = greekSelect.value;
            const optionType = optionTypeSelect.value;
            const positionType = positionTypeSelect.value;
            
            // Use the days to expiry input to calculate T
            const daysToExpiry = parseFloat(daysToExpiryInput.value) || 1; // Default to 1 if invalid
            const T = daysToExpiry / 365; // Trading days in a year
            
            const calculation = optionType === 'call' 
                ? calculateCallOption(S, K, DEFAULT_RATE, DEFAULT_DIVIDEND, iv, T)
                : calculatePutOption(S, K, DEFAULT_RATE, DEFAULT_DIVIDEND, iv, T);
            
            let value = calculation[greek];
            
            // Adjust for short positions (negative value)
            if (positionType === 'short') {
                value = -value;
            }
            
            return value;
        }

        // Generate data with reduced complexity for faster initial loading
        function generateReducedData(initialLoad) {
    const strikeStep = initialLoad ? 10 : 1;
    const ivStep = initialLoad ? 0.05 : 0.02;
    
    const data = [];
    strikeData = {};
    
    // CHANGED: Strike prices from 5600 to 6400 instead of 5800 to 6200
    for (let strike = 5600; strike <= 6400; strike += strikeStep) {
        const strikeDataPoints = [];
        
        for (let iv = 0.10; iv <= 0.90; iv += ivStep) {
            const greekValue = getGreekValue(DEFAULT_SPOT, strike, iv);
            strikeDataPoints.push({
                strike,
                iv,
                value: greekValue
            });
        }
        
        data.push(strikeDataPoints);
        strikeData[strike] = strikeDataPoints;
    }
    
    return data;
}

        // Generate color based on value (for surface coloring)
        function getColorForValue(value, min, max) {
            // Normalize value to 0-1 range
            const normalized = (value - min) / (max - min);
            
            // Red to green gradient
            let r = 1 - normalized;
            let g = normalized;
            let b = 0.1;
            
            // Convert to RGB color
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
        }

        // Map Greek names to display names
        function getGreekDisplayName(greek) {
            const greekMap = {
                    'delta': 'Delta (Δ)',
                    'gamma': 'Gamma (Γ)',
                    'vega': 'Vega (ν)',
                    'vanna': 'Vanna',
                    'charm': 'Charm',
                    'theta': 'Theta (Θ)',
                    'vomma': 'Vomma',
                    'veta': 'Veta',
                    'speed': 'Speed',
                    'zomma': 'Zomma',
                    'color': 'Color',
                    'ultima': 'Ultima',
                    'parmicharma': 'Parmicharma'
            };
            return greekMap[greek] || greek;
        }

        // Create text sprite without background, with larger text
        function createTextSprite(text, parameters) {
            if (parameters === undefined) parameters = {};
            
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize ? parameters.fontsize * 1.5 : 36; 
            const textColor = parameters.textColor || { r:1.0, g:1.0, b:1.0, a:1.0 };
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            canvas.width = 768;
            canvas.height = 384;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            context.font = "Bold " + fontsize + "px " + fontface;
            
            context.fillStyle = "rgba(" + textColor.r * 255 + "," + textColor.g * 255 + ","
                                        + textColor.b * 255 + "," + textColor.a + ")";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true 
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            const textWidth = context.measureText(text).width;
            sprite.scale.set(textWidth/6 + 50, 50, 1.0);
            
            return sprite;
        }

        // Set up enhanced lighting for dark theme visualization
        function setupLighting() {
            // Remove any existing lights
            scene.children.forEach(child => {
                if (child.isLight) scene.remove(child);
            });
            
            // Add ambient light for dark background
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.7);
            scene.add(ambientLight);
            
            // Add directional light with slight blue tint
            const directionalLight = new THREE.DirectionalLight(0xb4c2ff, 1.2);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Add secondary light source for better highlights
            const secondaryLight = new THREE.DirectionalLight(0xaaffcc, 0.5);
            secondaryLight.position.set(-1, 0.5, -1);
            scene.add(secondaryLight);
        }

        // Get color for a specific strike price
        function getColorForStrike(strike) {
    const minStrike = 5600; // CHANGED: from 5800
    const maxStrike = 6400; // CHANGED: from 6200
    const t = (strike - minStrike) / (maxStrike - minStrike);
    
    let r, g, b;
    
    if (t < 0.5) {
        const localT = t * 2;
        r = 0.1 + localT * 0.9;
        g = 0.3 + localT * 0.7;
        b = 1.0;
    } else {
        const localT = (t - 0.5) * 2;
        r = 1.0;
        g = 1.0 - localT * 0.9;
        b = 1.0 - localT * 0.9;
    }
    
    return new THREE.Color(r, g, b);
}
function getColorForIV(iv) {
    const minIV = 0.10;
    const maxIV = 0.90;
    const t = (iv - minIV) / (maxIV - minIV);
    
    // Blue to white to red gradient based on IV
    let r, g, b;
    
    if (t < 0.5) {
        // Deep blue to white (low IV to medium IV)
        const localT = t * 2;
        r = 0.1 + localT * 0.9;  // 0.1 to 1.0
        g = 0.3 + localT * 0.7;  // 0.3 to 1.0
        b = 1.0;                 // Always full blue
    } else {
        // White to deep red (medium IV to high IV)
        const localT = (t - 0.5) * 2;
        r = 1.0;                 // Always full red
        g = 1.0 - localT * 0.9;  // 1.0 to 0.1
        b = 1.0 - localT * 0.9;  // 1.0 to 0.1
    }
    
    return new THREE.Color(r, g, b);
}

        // Initialize Three.js scene
        function init() {
            try {
                initializationAttempted = true;
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Create camera
                const aspect = plotContainer.clientWidth / plotContainer.clientHeight;
                camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 2000);
                camera.position.set(0, 0, -600);
                camera.lookAt(0, 0, 0);
                
                // Create renderer with higher quality
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    precision: 'highp',
                    powerPreference: 'high-performance'
                });
                renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
                plotContainer.appendChild(renderer.domElement);
                
                // Set up enhanced lighting for dark theme
                setupLighting();
                
                // Add orbit controls
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.rotateSpeed = 0.5;
                } else {
                    throw new Error("OrbitControls not loaded");
                }
                
                // Create grid group
                gridGroup = new THREE.Group();
                scene.add(gridGroup);
                
                // Initialize raycaster for interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Add mouse move event listener for interaction
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);
                
                // Create initial plot with reduced data
                setTimeout(() => {
                    updatePlot(true); // true for reduced data set on initial load
                    
                    // Start animation
                    animate();
                    
                    // Clear the initialization timeout since we've successfully initialized
                    clearTimeout(initializationTimeout);
                }, 10);
                
            } catch (err) {
                clearTimeout(initializationTimeout);
                showFallbackUI("Error initializing 3D visualization. Switching to 2D mode.");
            }
        }

        // Mouse move handler for interaction
        function onMouseMove(event) {
    if (use2DMode || strikeLines.length === 0) return; // Check surfaceMesh instead of !surfaceMesh
    
    // Calculate mouse position in normalized device coordinates
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
}

        // Update value display based on raycaster intersection
        function updateValueDisplay() {
    if (!raycaster || !camera || strikeLines.length === 0 || !mouse) return;
    
    raycaster.setFromCamera(mouse, camera);
    
    // Intersect with all the objects (including invisible tube meshes)
    const intersectableObjects = strikeLines.filter(obj => 
        obj.geometry && 
        (obj.geometry.attributes || obj.geometry.parameters) && 
        !obj.material.map // Exclude text sprites
    );
    const intersects = raycaster.intersectObjects(intersectableObjects);
    
    if (intersects.length > 0) {
        const intersection = intersects[0];
        const point = intersection.point;
        const object = intersection.object;
        
        const gridSize = 150;
        const strikeRange = 6400 - 5600;
        const ivRange = 0.9 - 0.1;
        
        const scaleX = -gridSize / (strikeRange/2);
        const scaleZ = gridSize / (ivRange/2);
        
        const offsetX = -6000;
        const offsetZ = -0.5;
        
        // Convert coordinates back to data values
        const strike = Math.round((point.x / scaleX) - offsetX);
        let iv = parseFloat(((point.z / scaleZ) - offsetZ).toFixed(2));
        
        // If we hit a tube mesh with stored IV data, use that for more accuracy
        if (object.userData && object.userData.iv !== undefined) {
            iv = object.userData.iv;
        }
        
        // Clamp to valid ranges
        const clampedStrike = Math.max(5600, Math.min(6400, strike));
        const clampedIV = Math.max(0.10, Math.min(0.90, iv));
        
        // Get the actual Greek value from the intersection point's Y coordinate
        const maxAbsValueGlobal = Math.max(Math.abs(minValueGlobal), Math.abs(maxValueGlobal));
const scaleYGlobal = gridSize / (maxAbsValueGlobal || 1);
const actualValue = point.y / scaleYGlobal; // Direct scaling since we're zero-centered
        
        strikeValueElement.textContent = clampedStrike;
        ivValueElement.textContent = clampedIV.toFixed(2);
        greekValueElement.textContent = actualValue.toFixed(4);
    } else {
        strikeValueElement.textContent = '-';
        ivValueElement.textContent = '-';
        greekValueElement.textContent = '-';
    }
}
        // Animation loop
        function animate() {
            if (use2DMode) return; // Don't animate in 2D mode
            
            requestAnimationFrame(animate);
            if (controls) controls.update();
            
            // Update value display based on mouse position
            updateValueDisplay();
            
            if (renderer && scene && camera) renderer.render(scene, camera);
        }
        function getSmartScaling(minValue, maxValue) {
    // Check if values are predominantly on one side of zero
    const valueRange = maxValue - minValue;
    const zeroOffset = Math.abs(minValue) / valueRange; // How far zero is from min (0-1)
    
    // If zero is very close to one edge (within 10%), use asymmetric scaling
    if (zeroOffset < 0.1 || zeroOffset > 0.9) {
        // Asymmetric scaling - center around actual midpoint
        const offsetY = -(minValue + maxValue) / 2;
        const scaleY = 150 / (valueRange / 2 || 1);
        return { offsetY, scaleY, symmetric: false };
    } else {
        // Symmetric scaling around zero
        const maxAbsValue = Math.max(Math.abs(minValue), Math.abs(maxValue));
        const offsetY = 0;
        const scaleY = 150 / (maxAbsValue || 1);
        return { offsetY, scaleY, symmetric: true };
    }
}
        // Update the 3D plot
        function updatePlot(initialLoad = false) {
            try {
                loadingElement.style.display = 'flex';
                loadingElement.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Generating visualization...</div>
                    <div class="loading-tips">This may take a few moments</div>
                `;
                
                // Clear previous meshes
                meshes.forEach(mesh => {
                    if (scene) {
                        scene.remove(mesh);
                        // Clean up resources
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) {
                            if (Array.isArray(mesh.material)) {
                                mesh.material.forEach(material => material.dispose());
                            } else {
                                mesh.material.dispose();
                            }
                        }
                    }
                });
                meshes = [];
                
                // Clear grid group
                if (gridGroup) {
                    while(gridGroup.children.length > 0) {
                        const child = gridGroup.children[0];
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(material => material.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                        gridGroup.remove(child);
                    }
                }
                
                // Clear strike lines
                strikeLines.forEach(line => {
                    if (scene) {
                        scene.remove(line);
                        if (line.geometry) line.geometry.dispose();
                        if (line.material) line.material.dispose();
                    }
                });
                strikeLines = [];
                
                // Generate new data
                const surfaceData = generateReducedData(initialLoad);
                
                // Find min/max values for scaling
                let minValue = Infinity;
                let maxValue = -Infinity;
                
                surfaceData.forEach(strikePoints => {
                    strikePoints.forEach(point => {
                        minValue = Math.min(minValue, point.value);
                        maxValue = Math.max(maxValue, point.value);
                    });
                });
                minValueGlobal = minValue;
                maxValueGlobal = maxValue;
                
                // Create reference grid with labels
                createBackgroundGrid(minValue, maxValue);
                
                // Scaling factors for better visualization
                const gridSize = 150;
                const strikeRange = 6400 - 5600;
                const ivRange = 0.9 - 0.1;
                const valueRange = maxValue - minValue || 1; // Avoid division by zero
                
                // Use negative scaleX to invert the X-axis
                const scaleX = -gridSize / (strikeRange/2);
                const scaling = getSmartScaling(minValue, maxValue);
                const scaleY = scaling.scaleY;

                const scaleZ = gridSize / (ivRange/2);
                
                // Offset to center the plot
                const offsetX = -6000;
                const offsetY = scaling.offsetY;
                const offsetZ = -0.5;
                
                loadingElement.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Creating visualization...</div>
                    <div class="loading-tips">Almost there!</div>
                `;
                
                // Create surface geometry
                const geometrySurface = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const indices = [];
                
                // Create surface mesh vertices
                const rows = surfaceData.length;
                const cols = surfaceData[0]?.length || 0;
                
                // Create vertices and vertex colors
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const point = surfaceData[i][j];
                        const x = (point.strike + offsetX) * scaleX;
                        const y = (point.value + offsetY) * scaleY;
                        const z = (point.iv + offsetZ) * scaleZ;
                        
                        vertices.push(x, y, z);
                        
                        // Color based on the value
                        const color = getColorForValue(point.value, minValue, maxValue);
                        const rgb = color.match(/\d+/g).map(Number);
                        
                        colors.push(rgb[0]/255, rgb[1]/255, rgb[2]/255);
                    }
                }
                
                // Create faces (triangles) for the surface
                for (let i = 0; i < rows - 1; i++) {
                    for (let j = 0; j < cols - 1; j++) {
                        const a = i * cols + j;
                        const b = i * cols + (j + 1);
                        const c = (i + 1) * cols + j;
                        const d = (i + 1) * cols + (j + 1);
                        
                        // First triangle
                        indices.push(a, c, b);
                        
                        // Second triangle
                        indices.push(b, c, d);
                    }
                }
                
                geometrySurface.setIndex(indices);
                geometrySurface.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometrySurface.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometrySurface.computeVertexNormals();
                
                // Enhanced material for better appearance on dark background
                //const materialSurface = new THREE.MeshPhongMaterial({
                //   vertexColors: true,
                //    side: THREE.DoubleSide,
                //    shininess: 70,
                //    flatShading: false,
                //    transparent: false,
                //    depthWrite: true
                //});
                
                //surfaceMesh = new THREE.Mesh(geometrySurface, materialSurface);
                //scene.add(surfaceMesh);
                //meshes.push(surfaceMesh);
                
                // Add lines along the strike curves (one line for each strike)
                addIVLines(minValue, maxValue);
                
                // CREATE THE INVISIBLE INTERACTION SURFACE
                //createInteractionSurface(minValue, maxValue);
                
                // Add title and axis labels
                addAxisLabels(minValue, maxValue);
                
                loadingElement.style.display = 'none';
                valueDisplay.style.display = 'block';
                
                // If this was the initial load with reduced data, schedule a full update
                if (initialLoad) {
                    const fullUpdateMessage = document.createElement('div');
                    fullUpdateMessage.textContent = "Loading full resolution data...";
                    fullUpdateMessage.style.position = 'absolute';
                    fullUpdateMessage.style.bottom = '10px';
                    fullUpdateMessage.style.right = '10px';
                    fullUpdateMessage.style.background = 'rgba(25, 30, 45, 0.7)';
                    fullUpdateMessage.style.padding = '5px 10px';
                    fullUpdateMessage.style.borderRadius = '4px';
                    fullUpdateMessage.style.fontSize = '12px';
                    fullUpdateMessage.style.color = '#ffffff';
                    plotContainer.appendChild(fullUpdateMessage);
                    
                    // Schedule full data update after 2 seconds
                    setTimeout(() => {
                        updatePlot(false);
                        fullUpdateMessage.remove();
                    }, 2000);
                }
                
            } catch (err) {
                loadingElement.innerHTML = `
                    <div>Error generating visualization</div>
                    <div class="loading-tips">Try refreshing the page or use 2D mode</div>
                    <button id="error2DButton" class="fallback-button">Switch to 2D Mode</button>
                `;
                loadingElement.style.display = 'flex';
                
                // Add event listener for 2D switch button
                document.getElementById('error2DButton').addEventListener('click', function() {
                    use2DMode = true;
                    init2DMode();
                    loadingElement.style.display = 'none';
                });
            }
        }
        function createInteractionSurface(minValue, maxValue) {
    // Create a simplified invisible surface for mouse interaction
    const gridSize = 150;
    const strikeRange = 6400 - 5600; // Correct range
    const ivRange = 0.9 - 0.1;
    const valueRange = maxValue - minValue || 1;
    
    const scaleX = -gridSize / (strikeRange/2);
    const maxAbsValue = Math.max(Math.abs(minValue), Math.abs(maxValue));
    const scaleY = gridSize / (maxAbsValue || 1);
    const scaleZ = gridSize / (ivRange/2);
    
    const offsetX = -6000;
    const offsetY = 0;
    const offsetZ = -0.5;
    
    // Create a simple plane geometry for interaction
    const geometry = new THREE.PlaneGeometry(gridSize * 2, gridSize * 2, 40, 40);
    
    // Position and rotate the plane to match the data orientation
    geometry.rotateX(-Math.PI / 2); // Rotate to be horizontal
    geometry.translate(0, offsetY, 0); // Move to center
    
    // Create invisible material
    const material = new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
    });
    
    // Create the mesh
    surfaceMesh = new THREE.Mesh(geometry, material);
    scene.add(surfaceMesh);
    meshes.push(surfaceMesh);
}

        // Add lines along each strike price curve
        function addIVLines(minValue, maxValue) {
    const keyIVs = [];
    for (let iv = 0.10; iv <= 0.90; iv += 0.01) {
        keyIVs.push(parseFloat(iv.toFixed(2)));
    }
    
    const gridSize = 150;
    const strikeRange = 6400 - 5600; // CHANGED: 800 instead of 400
    const ivRange = 0.9 - 0.1;
    const valueRange = maxValue - minValue || 1;
    
    const scaleX = -gridSize / (strikeRange/2);
    const maxAbsValue = Math.max(Math.abs(minValue), Math.abs(maxValue));
    const scaleY = gridSize / (maxAbsValue || 1);
    const scaleZ = gridSize / (ivRange/2);
    
    const offsetX = -6000;
    const offsetY = 0;
    const offsetZ = -0.5;
    
    keyIVs.forEach(iv => {
        const linePoints = [];
        
        // CHANGED: Create points from 5600 to 6400
        for (let strike = 5600; strike <= 6400; strike += 1) {
            const greekValue = getGreekValue(DEFAULT_SPOT, strike, iv);
            
            const x = (strike + offsetX) * scaleX;
            const y = greekValue * scaleY;
            const z = (iv + offsetZ) * scaleZ;
            
            linePoints.push(new THREE.Vector3(x, y, z));
        }
        
        if (linePoints.length > 0) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            
            const color = getColorForIV(iv);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: color,
                linewidth: 1,
                transparent: false,
                opacity: 1.0
            });
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            strikeLines.push(line);
            // Create an invisible thicker line for better mouse interaction
line.userData = { iv: iv };
            if (Math.abs(iv % 0.1) < 0.005) {
                const lastPoint = linePoints[linePoints.length - 1];
                
                const ivLabel = createTextSprite(iv.toFixed(1), {
                    fontsize: 30,
                    textColor: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
                });
                
                ivLabel.position.set(lastPoint.x - 10, lastPoint.y, lastPoint.z);
                ivLabel.scale.set(120, 60, 1.0);
                scene.add(ivLabel);
                strikeLines.push(ivLabel);
            }
        }
    });
}

        // Create a background grid with labeled axes
        function createBackgroundGrid(minValue, maxValue) {
    const gridSize = 150;
    
    const container = new THREE.Object3D();
    gridGroup.add(container);
            
            // Material with depthWrite = false to ensure grid is always visible
            const gridMaterial = new THREE.LineBasicMaterial({ 
    color: 0xcccccc,        // Changed from 0x000000 to light grey
    transparent: true,
    opacity: 0.1,           // Increased from 0.4 for better visibility
    depthWrite: false,
    depthTest: true,
    linewidth: 1.5
});
            
            // Denser grid
            const minorGridStep = 15; 
            
            // XZ Plane (bottom)
            const xzGridGeometry = new THREE.BufferGeometry();
            const xzVertices = [];
            
            // X lines
            for (let x = -gridSize; x <= gridSize; x += minorGridStep) {
                xzVertices.push(x, 0, -gridSize, x, 0, gridSize);
            }
            
            // Z lines
            for (let z = -gridSize; z <= gridSize; z += minorGridStep) {
                xzVertices.push(-gridSize, 0, z, gridSize, 0, z);
            }
            
            xzGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(xzVertices, 3));
            const xzGrid = new THREE.LineSegments(xzGridGeometry, gridMaterial);
            container.add(xzGrid);
            
            // XY Plane (back wall)
            const xyGridGeometry = new THREE.BufferGeometry();
            const xyVertices = [];
            
            // X lines
            for (let x = -gridSize; x <= gridSize; x += minorGridStep) {
                xyVertices.push(x, -gridSize, gridSize, x, gridSize, gridSize);
            }
            
            // Y lines
            for (let y = -gridSize; y <= gridSize; y += minorGridStep) {
                xyVertices.push(-gridSize, y, gridSize, gridSize, y, gridSize);
            }
            
            xyGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(xyVertices, 3));
            const xyGrid = new THREE.LineSegments(xyGridGeometry, gridMaterial);
            container.add(xyGrid);
            
            // YZ Plane (left wall)
            const yzGridGeometry = new THREE.BufferGeometry();
            const yzVertices = [];
            
            // Y lines
            for (let y = -gridSize; y <= gridSize; y += minorGridStep) {
                yzVertices.push(-gridSize, y, -gridSize, -gridSize, y, gridSize);
            }
            
            // Z lines
            for (let z = -gridSize; z <= gridSize; z += minorGridStep) {
                yzVertices.push(-gridSize, -gridSize, z, -gridSize, gridSize, z);
            }
            
            yzGridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(yzVertices, 3));
            const yzGrid = new THREE.LineSegments(yzGridGeometry, gridMaterial);
            container.add(yzGrid);
            
            // Axes with brighter color
            const axesMaterial = new THREE.LineBasicMaterial({ 
                color: 0xcccccc,
                linewidth: 2,
                transparent: false,
                opacity: 1.0
            });
            
            // X-axis - at maximum Z (back)
            const xAxisGeometry = new THREE.BufferGeometry();
            const xAxisVertices = new Float32Array([
                -gridSize, 0, gridSize,
                gridSize, 0, gridSize
            ]);
            xAxisGeometry.setAttribute('position', new THREE.BufferAttribute(xAxisVertices, 3));
            const xAxis = new THREE.Line(xAxisGeometry, axesMaterial);
            container.add(xAxis);
            
            // Y-axis - at maximum Z (back)
            const yAxisGeometry = new THREE.BufferGeometry();
            const yAxisVertices = new Float32Array([
                -gridSize, -gridSize, gridSize,
                -gridSize, gridSize, gridSize
            ]);
            yAxisGeometry.setAttribute('position', new THREE.BufferAttribute(yAxisVertices, 3));
            const yAxis = new THREE.Line(yAxisGeometry, axesMaterial);
            container.add(yAxis);
            
            // Z-axis
            const zAxisGeometry = new THREE.BufferGeometry();
            const zAxisVertices = new Float32Array([
                -gridSize, 0, -gridSize,
                -gridSize, 0, gridSize
            ]);
            zAxisGeometry.setAttribute('position', new THREE.BufferAttribute(zAxisVertices, 3));
            const zAxis = new THREE.Line(zAxisGeometry, axesMaterial);
            container.add(zAxis);
            
            // White text for axis labels on dark background
            const axisLabelFontSize = 30;
            const axisLabelScale = new THREE.Vector3(120, 60, 1.0);
            const textColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
            
            // Strike (X-axis) labels - inverted order and at foreground
            const strikeValues = [6400, 6200, 6000, 5800, 5600]; // CHANGED: new values
    const strikePositions = [-gridSize * 0.8, -gridSize * 0.4, 0, gridSize * 0.4, gridSize * 0.8];
    
    strikePositions.forEach((pos, index) => {
        const label = createTextSprite(strikeValues[index].toString(), {
            fontsize: 30,
            textColor: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
        });
        label.position.set(pos, -15, -gridSize - 15);
        label.scale.set(120, 60, 1.0);
        container.add(label);
    });
            
            // IV (Z-axis) labels
            const ivValues = [0.1, 0.3, 0.5, 0.7, 0.9];
            const ivPositions = [-gridSize * 0.8, -gridSize * 0.4, 0, gridSize * 0.4, gridSize * 0.8];
            
            ivPositions.forEach((pos, index) => {
                const label = createTextSprite(ivValues[index].toFixed(1), {
                    fontsize: axisLabelFontSize,
                    textColor: textColor
                });
                label.position.set(-gridSize - 15, -15, pos);
                label.scale.copy(axisLabelScale);
                container.add(label);
            });
            
            // Greek value (Y-axis) labels - at foreground (minimum Z)
            // Greek value (Y-axis) labels - symmetric around zero
const maxAbsValue = Math.max(Math.abs(minValue), Math.abs(maxValue));
const labelValues = [
    -maxAbsValue,
    -maxAbsValue/2,
    0,
    maxAbsValue/2,
    maxAbsValue
];

labelValues.forEach((value) => {
    const position = (value / (maxAbsValue || 1)) * gridSize;
    const label = createTextSprite(value.toFixed(3), {
        fontsize: 30,
        textColor: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
    });
    label.position.set(-gridSize - 25, position, -gridSize - 15);
    label.scale.set(120, 60, 1.0);
    container.add(label);
});
        }

        // Add title and main axis labels
        function addAxisLabels(minValue, maxValue) {
            const gridSize = 150;
            const textColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
            
            // X Label
            const xLabel = createTextSprite("Strike Price (K)", {
                fontsize: 24,
                textColor: textColor
            });
            xLabel.position.set(0, -40, -gridSize - 15);
            scene.add(xLabel);
            meshes.push(xLabel);
            
            // Y Label
            const yLabel = createTextSprite(getGreekDisplayName(greekSelect.value), {
                fontsize: 24,
                textColor: textColor
            });
            yLabel.position.set(-gridSize - 25, 50, -gridSize - 15);
            scene.add(yLabel);
            meshes.push(yLabel);
            
            // Z Label
            const zLabel = createTextSprite("Implied Volatility (IV)", {
                fontsize: 24,
                textColor: textColor
            });
            zLabel.position.set(-gridSize - 25, -40, 0);
            scene.add(zLabel);
            meshes.push(zLabel);
        }

        // Initialize on load
        window.addEventListener('load', function() {
            // First check if WebGL is supported
            if (!checkWebGLSupport()) {
                showFallbackUI('WebGL is not supported by your browser. Switching to 2D mode.');
                return;
            }
            
            // Set a timeout to detect if initialization takes too long
            initializationTimeout = setTimeout(function() {
                if (!initializationAttempted) {
                    loadingElement.innerHTML = `
                        <div>Still loading...</div>
                        <div class="loading-spinner"></div>
                        <div class="loading-tips">
                            This is taking longer than expected. You can:
                            <br>- Continue waiting
                            <br>- Try refreshing the page
                            <br>- Switch to 2D mode
                        </div>
                        <button id="switch2DButton" class="fallback-button">Switch to 2D Mode</button>
                    `;
                    
                    document.getElementById('switch2DButton').addEventListener('click', function() {
                        clearTimeout(initializationTimeout);
                        use2DMode = true;
                        init2DMode();
                        loadingElement.style.display = 'none';
                    });
                }
            }, 10000); // 10 seconds timeout
            
            // Try to initialize
            try {
                init();
            } catch (e) {
                clearTimeout(initializationTimeout);
                showFallbackUI('Failed to initialize 3D visualization. Switching to 2D mode.');
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (use2DMode) {
                init2DMode(); // Redraw 2D chart
            } else if (camera && renderer) {
                camera.aspect = plotContainer.clientWidth / plotContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(plotContainer.clientWidth, plotContainer.clientHeight);
            }
        });

        // Event listeners for controls
        greekSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        optionTypeSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        positionTypeSelect.addEventListener('change', () => {
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
        
        daysToExpiryInput.addEventListener('change', () => {
            // Validate input: ensure it's between 0.01 and 365
            let days = parseFloat(daysToExpiryInput.value);
            if (isNaN(days) || days < 0.000001) days = 0.000001;
            if (days > 365) days = 365;
            daysToExpiryInput.value = days; // Update with validated value
            
            if (use2DMode) {
                init2DMode();
            } else {
                updatePlot();
            }
        });
    </script>
</body>
</html>
